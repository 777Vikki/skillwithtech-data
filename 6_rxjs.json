[
    {
        "name": "<p><strong>Basic</strong></p>",
        "subjectId": 6,
        "sectionId": 51,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "",
                "subjectId": 6,
                "sectionId": 51,
                "subSectionId": -1,
                "contentId": 144,
                "text": "<p><strong>What is RxJS?</strong></p>"
            },
            {
                "description": "",
                "subjectId": 6,
                "sectionId": 51,
                "subSectionId": -1,
                "contentId": 145,
                "text": "<p><strong>What are observables in Angular?</strong></p>"
            },
            {
                "description": "",
                "subjectId": 6,
                "sectionId": 51,
                "subSectionId": -1,
                "contentId": 146,
                "text": "<p><strong>How do RxJS differ from promises?</strong></p>"
            },
            {
                "description": "",
                "subjectId": 6,
                "sectionId": 51,
                "subSectionId": -1,
                "contentId": 147,
                "text": "<p><strong>Why is RxJS used in Angular?</strong></p>"
            },
            {
                "description": "",
                "subjectId": 6,
                "sectionId": 51,
                "subSectionId": -1,
                "contentId": 148,
                "text": "<p><strong>If Observables are more powerful than Promises, then why do we still use Promises?</strong></p>"
            },
            {
                "description": "",
                "subjectId": 6,
                "sectionId": 51,
                "subSectionId": -1,
                "contentId": 149,
                "text": "<p><strong>How do you subscribe to an Observable? How do you unsubscribe?</strong></p>"
            },
            {
                "description": "",
                "subjectId": 6,
                "sectionId": 51,
                "subSectionId": -1,
                "contentId": 150,
                "text": "<p><strong>What is the use of pipe() in RxJS?</strong></p>"
            },
            {
                "description": "",
                "subjectId": 6,
                "sectionId": 51,
                "subSectionId": -1,
                "contentId": 151,
                "text": "<p><strong>How to chain HTTP calls in sequence using RxJS?</strong></p>"
            },
            {
                "description": "",
                "subjectId": 6,
                "sectionId": 51,
                "subSectionId": -1,
                "contentId": 152,
                "text": "<p><strong>What is the difference between tap and map?</strong></p>"
            },
            {
                "description": "<p>When an observable <strong>keeps emitting</strong> but you <strong>never unsubscribe</strong>, it stays in memory even if the component is destroyed.</p></br><p>Example leak sources:</p><ul><li><code>interval()</code>, <code>timer()</code>, <code>WebSocket</code></li><li>Service observables like <code>BehaviorSubject</code></li><li><code>HttpClient</code>? ðŸŸ¢ Safe (Auto-completes âœ…)</li></ul></br><p>There are many ways to prevent memory leaks:</p><ul><li>We can unsubscribe manually in <code>ngOnDestroy()</code>.</li><li>We can use <code>takeUntil()</code> with a notifier, and it unsubscribes when the notifier completes.</li><li>If we use the <code>async</code> pipe, it automatically unsubscribes when the component is destroyed.</li><li>We can use the <code>take()</code> or <code>first()</code> operators, as they automatically complete after the required emission.</li></ul></br>",
                "subjectId": 6,
                "sectionId": 51,
                "subSectionId": -1,
                "contentId": 153,
                "text": "<p><strong>How do you handle memory leaks with Observables?</strong></p>"
            },
            {
                "description": "<p><strong>Creation Operators</strong> are used to create new Observables from scratch or from various sources, such as:</p><ul><li><strong>of()</strong> â†’ creates an observable from a value.</li><li><strong>from()</strong> â†’ creates an observable from an array or a promise.</li><li><strong>fromEvent()</strong> â†’ creates an observable from a DOM event.</li></ul><p><strong>Transformation Operators</strong> are used to transform data emitted by an observable, such as:</p><ul><li><strong>switchMap()</strong> â†’ cancels the previous observable if a new value is emitted.</li><li><strong>mergeMap()</strong> â†’ runs multiple observables in parallel and subscribes to all of them concurrently.</li><li><strong>concatMap()</strong> â†’ waits for each observable to complete before moving to the next.</li><li><strong>exhaustMap()</strong> â†’ ignores new emissions from the source until the current inner observable completes.</li></ul><p><strong>Filtering Operators</strong> are used to filter emitted values based on conditions, such as:</p><ul><li><strong>take(n)</strong> â†’ emits only the first <em>n</em> values and then completes.</li><li><strong>takeUntil()</strong> â†’ unsubscribes from the source observable when a notifier observable emits.</li><li><strong>skip(n)</strong> â†’ ignores the first <em>n</em> emitted values and emits the rest.</li></ul><p><strong>Combination Operators</strong> are used to combine multiple observables into one, such as:</p><ul><li><strong>combineLatest()</strong> â†’ emits the latest values from multiple observables whenever any of them emits.</li><li><strong>forkJoin()</strong> â†’ emits the last value from each observable once all have completed.</li></ul>",
                "subjectId": 6,
                "sectionId": 51,
                "subSectionId": -1,
                "contentId": 154,
                "text": "<p><strong>Can you explain five RxJS operators with example?</strong></p>"
            }
        ]
    },
    {
        "name": "<p><strong>Subject, BehaviorSubject, ReplaySubject, and AsyncSubject</strong></p>",
        "subjectId": 6,
        "sectionId": 52,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "<p>All are <strong>special types of Observables</strong> in <strong>RxJS</strong> that act as both <strong>Observable</strong> and <strong>Observer</strong> (you can <strong>subscribe</strong> and also <strong>next values</strong>).</p></br><p>ðŸ”¹ <strong>Subject: </strong>A <strong>Subject</strong> does <strong>not store any values</strong>. Subscribers only receive values <strong>emitted after they subscribe</strong>.</p><p>ðŸ‘‰ Best used for <strong>event emitters</strong>, like <strong>button clicks</strong> or <strong>WebSocket streams</strong>.</p></br><p>ðŸ”¹ <strong>BehaviorSubject: </strong>A <strong>BehaviorSubject</strong> requires an <strong>initial value</strong> and always stores the <strong>latest emitted value</strong>.</p><p>ðŸ‘‰ New subscribers immediately receive the <strong>most recent value</strong> along with <strong>future values</strong>.</p><p>Commonly used for <strong>state management</strong> in <strong>Angular applications</strong>.</p></br><p>ðŸ”¹ <strong>ReplaySubject: </strong>A <strong>ReplaySubject</strong> stores a <strong>buffer of past values</strong> (defined by <strong>buffer size</strong>) and <strong>replays</strong> those values to <strong>new subscribers</strong>, along with <strong>future values</strong>.</p><p>ðŸ‘‰ Useful when you want subscribers to get some <strong>history</strong>, like <strong>chat messages</strong> or <strong>cached data</strong>.</p></br><p>ðŸ”¹ <strong>AsyncSubject: </strong>An <strong>AsyncSubject</strong> emits <strong>only the last value</strong> and <strong>only when the subject completes</strong>.</p><p>ðŸ‘‰ All subscribers receive the <strong>same final value</strong>.</p></br><p>Typically used when you want to expose a <strong>single final result</strong>, such as an <strong>HTTP request</strong> or a <strong>long calculation</strong>.</p>",
                "subjectId": 6,
                "sectionId": 52,
                "subSectionId": -1,
                "contentId": 155,
                "text": "<p><strong>What is the difference between Subject, BehaviorSubject, ReplaySubject, and AsyncSubject in RxJS? Can you give a scenario where each would be most appropriate?</strong></p>"
            }
        ]
    },
    {
        "name": "<p><strong>Types of observable</strong></p>",
        "subjectId": 6,
        "sectionId": 53,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "<p><strong>Creation Operators</strong> are used to create new Observables from scratch or from various sources, such as:</p><ul><li><strong>of()</strong> â†’ creates an observable from a value.</li><li><strong>from()</strong> â†’ creates an observable from an array or a promise.</li><li><strong>fromEvent()</strong> â†’ creates an observable from a DOM event.</li></ul><p><strong>Transformation Operators</strong> are used to transform data emitted by an observable, such as:</p><ul><li><strong>switchMap()</strong> â†’ cancels the previous observable if a new value is emitted.</li><li><strong>mergeMap()</strong> â†’ runs multiple observables in parallel and subscribes to all of them concurrently.</li><li><strong>concatMap()</strong> â†’ waits for each observable to complete before moving to the next.</li><li><strong>exhaustMap()</strong> â†’ ignores new emissions from the source until the current inner observable completes.</li></ul><p><strong>Filtering Operators</strong> are used to filter emitted values based on conditions, such as:</p><ul><li><strong>take(n)</strong> â†’ emits only the first <em>n</em> values and then completes.</li><li><strong>takeUntil()</strong> â†’ unsubscribes from the source observable when a notifier observable emits.</li><li><strong>skip(n)</strong> â†’ ignores the first <em>n</em> emitted values and emits the rest.</li></ul><p><strong>Combination Operators</strong> are used to combine multiple observables into one, such as:</p><ul><li><strong>combineLatest()</strong> â†’ emits the latest values from multiple observables whenever any of them emits.</li><li><strong>forkJoin()</strong> â†’ emits the last value from each observable once all have completed.</li><li><strong>zip()</strong> â†’ <strong>zip</strong> is a <strong>combination operator</strong> in <strong>RxJS</strong> that combines multiple <strong>Observables</strong> by <strong>pairing their emitted values by index</strong>.</li></ul><pre data-language=\"plain\">\nzip(of(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;), of(1, 2, 3)).subscribe(val =&gt; console.log(&#39;zip:&#39;, val));  \n// [&#39;A&#39;,1], [&#39;B&#39;,2], [&#39;C&#39;,3]\n\n</pre></br><ul><li><strong>merge()</strong> â†’ <strong>merge</strong> is a <strong>combination operator</strong> in <strong>RxJS</strong> that combines multiple <strong>Observables</strong> and emits <strong>all their values as they come</strong> â€” <strong>concurrently</strong>.</li><li><strong>concat()</strong> â†’ <strong>concat</strong> is a <strong>combination operator</strong> in <strong>RxJS</strong> that combines multiple <strong>Observables in sequence</strong>, emitting values from each <strong>only after the previous completes</strong>.</li></ul>",
                "subjectId": 6,
                "sectionId": 53,
                "subSectionId": -1,
                "contentId": 156,
                "text": "<p><strong>Can you explain types of  operators in sort?</strong></p>"
            },
            {
                "description": "<p><code>map</code> transforms the data in the Observable pipeline, while <code>tap</code> is used for side effects like logging without modifying the data.</p>",
                "subjectId": 6,
                "sectionId": 53,
                "subSectionId": -1,
                "contentId": 157,
                "text": "<p>What is different between <strong>tab </strong>and <strong>map</strong>?</p>"
            }
        ]
    }
]