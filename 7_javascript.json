[
    {
        "name": "<p><strong>Basic</strong></p>",
        "subjectId": 7,
        "sectionId": 54,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "<p>JavaScript (often abbreviated as <strong>JS</strong>) is a <strong>high-level, interpreted programming language</strong> that is widely used to make web pages interactive and dynamic.</p></br><p>It runs in the browser using engines like <strong>V8 (Chrome)</strong> or <strong>SpiderMonkey (Firefox)</strong>, and can also run on servers via <strong>Node.js</strong>. With JavaScript, developers can manipulate the <strong>DOM</strong>, handle <strong>events</strong>, perform <strong>asynchronous operations</strong> (AJAX, Fetch, Promises, async/await), and build <strong>full-stack applications</strong>.</p>",
                "subjectId": 7,
                "sectionId": 54,
                "subSectionId": -1,
                "contentId": 158,
                "text": "<p>What is JavaScript?</p>"
            }
        ]
    },
    {
        "name": "<p><strong>Call(), apply() and bind()</strong></p>",
        "subjectId": 7,
        "sectionId": 55,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "<pre data-language=\"plain\">\nfunction greet(greeting, punctuation) {\n  console.log(`${greeting}, ${this.name}${punctuation}`);\n}\n\nconst person = { name: &#39;Vivek&#39; };\n</pre></br><p><strong>1. call(): </strong></p><p>Invokes a function <strong>immediately</strong> and allows us to set its <code>this</code> context.</p><p>Arguments are passed <strong>individually</strong>.</p><pre data-language=\"plain\">\ngreet.call(person, &#39;Hello&#39;, &#39;!&#39;); // Hello, Vivek!\n\n</pre><p><strong>Use case:</strong> Call a function with a different this and pass arguments one by one.</p></br><p><strong>2. apply():</strong></p><p>Invokes a function <strong>immediately</strong> and allows us to set its <code>this</code> context.</p><p>Arguments are passed <strong>individually</strong>.</p><pre data-language=\"plain\">\ngreet.apply(person, [&#39;Hi&#39;, &#39;!!!&#39;]); // Hi, Vivek!!!\n\n</pre><p><strong>Use case:</strong> Call a function with a different this when arguments are already in an array.</p></br><p><strong>3. bind(): </strong> <code>bind()</code> returns a new function with <code>this</code> permanently bound, which can be called later.</p><pre data-language=\"plain\">\nconst boundGreet = greet.bind(person, &#39;Hey&#39;);\nboundGreet(&#39;!!!&#39;); // Hey, Vivek!!!\n</pre></br><p><strong>Use case:</strong></p><p>When you need a function to be called later but with a specific this.</p><p>Commonly used in event handlers in JavaScript/Angular.</p>",
                "subjectId": 7,
                "sectionId": 55,
                "subSectionId": -1,
                "contentId": 159,
                "text": "<p>Explain the difference between <strong>call()</strong>, <strong>apply()</strong>, and <strong>bind()</strong> methods in <strong>JavaScript</strong>. When would you use each?</p>"
            }
        ]
    },
    {
        "name": "<p><strong>Closure</strong></p>",
        "subjectId": 7,
        "sectionId": 56,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "<p>A <strong>closure in JavaScript</strong> is a feature where an <strong>inner function remembers and can access variables</strong> from its <strong>outer function‚Äôs scope</strong>, even after the outer function has finished executing.</p></br><p><strong>Closures </strong>help <strong>Angular </strong>by allowing us to create <strong>utilities </strong>that maintain private state‚Äîsuch as <strong>debouncers, feature toggles, and cached API results</strong>‚Äîwithout storing everything in <strong>components </strong>or <strong>services</strong>.</p></br><p><strong>Closures </strong>provide <strong>encapsulation (Hiding internal data) </strong>in <strong>JavaScript</strong>. They allow us to create<strong> private variables</strong> and expose only controlled functionality, similar to private members in <strong>object-oriented programming</strong>.</p></br><p><strong>Notes:</strong></p><p><strong>1. Closures</strong> store their <strong>variables </strong>in the <strong>JavaScript lexical environment</strong>, not in <strong>Angular components </strong>or <strong>services</strong>.</p><p>This memory is kept alive by the <strong>inner function reference</strong>, so even if the <strong>outer function</strong> finishes, the <strong>variables </strong>remain accessible.</p></br><p><strong>2.</strong> The<strong> Lexical Environment </strong>consists of the <strong>local memory </strong>and a <strong>reference to the Lexical Environment of its parent</strong>. <span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">A </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">Lexical Environment</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\"> is created </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">whenever an Execution Context is created</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">.</span></p></br><p><strong>3.</strong> A <strong>utility</strong> (or <strong>utility function</strong> / <strong>utility file</strong>) simply means: A small reusable helper function that performs a common task.</p>",
                "subjectId": 7,
                "sectionId": 56,
                "subSectionId": -1,
                "contentId": 160,
                "text": "<p>What is closures in JavaScript?</p>"
            },
            {
                "description": "<pre data-language=\"plain\">\n// üëâ debounce.ts\n\nexport function debounce(fn: (...args: any[]) =&gt; void, delay: number) {\n  let timer: any;\n\n  return function (...args: any[]) {\n    clearTimeout(timer);\n\n    timer = setTimeout(() =&gt; {\n      fn.apply(this, args);\n    }, delay);\n  };\n}\n</pre></br><pre data-language=\"plain\">\n// üëâ search.component.ts\n\nimport { Component } from &#39;@angular/core&#39;;\nimport { debounce } from &#39;./debounce&#39;;\n\n@Component({\n  selector: &#39;app-search&#39;,\n  standalone: true,\n  template: `\n    &lt;input type=&quot;text&quot; (input)=&quot;search($event)&quot; placeholder=&quot;Search...&quot; /&gt;\n  `,\n})\nexport class SearchComponent {\n  search = debounce((event: any) =&gt; {\n    console.log(&#39;API call for:&#39;, event.target.value);\n  }, 500);\n}\n</pre>",
                "subjectId": 7,
                "sectionId": 56,
                "subSectionId": -1,
                "contentId": 161,
                "text": "<p>Create a Debounce Utility Using Closure</p>"
            },
            {
                "description": "<pre data-language=\"plain\">\n// Create a private counter in a service\n\n@Injectable({ providedIn: &#39;root&#39; })\nexport class CounterService {\n  private counter = (() =&gt; {\n    let count = 0;\n    return () =&gt; ++count;   // closure\n  })();\n\n  getNextId() {\n    return this.counter();\n  }\n}\n</pre></br><pre data-language=\"plain\">\n// Usage:\n\nconsole.log(this.counterService.getNextId()); // 1\nconsole.log(this.counterService.getNextId()); // 2\n</pre>",
                "subjectId": 7,
                "sectionId": 56,
                "subSectionId": -1,
                "contentId": 162,
                "text": "<p>Create a private counter in a service</p>"
            },
            {
                "text": "<p>Create a Feature Toggle (Dark Mode / Any Flag) Using Closure</p>",
                "sectionId": 56,
                "subSectionId": -1,
                "subjectId": 7,
                "contentId": 401,
                "description": "<pre data-language=\"plain\">\n// üü¶ toggle.util.ts (closure-based toggle)\n\nexport function createToggle() {\n  let state = false; // private variable\n\n  return {\n    toggle: () =&gt; (state = !state),\n    getState: () =&gt; state,\n  };\n}\n</pre></br><pre data-language=\"plain\">\n// üü¶ Use in Angular Component / Service\n\nimport { Component } from &#39;@angular/core&#39;;\nimport { createToggle } from &#39;./toggle.util&#39;;\n\n@Component({\n  selector: &#39;app-theme&#39;,\n  standalone: true,\n  template: `\n    &lt;button (click)=&quot;toggleTheme()&quot;&gt;Toggle Theme&lt;/button&gt;\n    &lt;div [class.dark]=&quot;theme.getState()&quot;&gt;Theme: {{ theme.getState() ? &#39;Dark&#39; : &#39;Light&#39; }}&lt;/div&gt;\n  `\n})\nexport class ThemeComponent {\n  theme = createToggle(); // closure maintains state\n\n  toggleTheme() {\n    this.theme.toggle();\n  }\n}\n</pre></br>"
            },
            {
                "description": "<pre data-language=\"plain\">\nfunction x() {\n    for (var i = 1; i &lt;= 5; i++) {\n        setTimeout(function() {\n            console.log(i);\n        }, i * 1000);\n    }\n}\nx(); // O/P: 6 6 6 6 6\n</pre></br><p><strong>Explain: </strong><code>var</code> is function-scoped, so all iterations share the same <code>i</code>. By the time the <code>setTimeout</code> callbacks execute, the loop has finished, and <code>i</code> is 6. That‚Äôs why the output is <code>6 6 6 6 6</code>.</p></br><pre data-language=\"plain\">\nfunction x() {\n    for (let i = 1; i &lt;= 5; i++) {\n        setTimeout(function() {\n            console.log(i);\n        }, i * 1000);\n    }\n}\nx(); // O/P: 1 2 3 4 5\n</pre></br><p><strong>Explain:</strong> When we use <code>let</code>, each iteration has its own <strong>block-scoped </strong><code><strong>i</strong></code>. So, when the <code>setTimeout</code> callbacks run, they print the correct values (1‚Äì5).</p></br><pre data-language=\"plain\">\nfunction x() {\n    for (var i = 1; i &lt;= 5; i++) {\n        function close(x) {\n            setTimeout(function() {\n                console.log(x);\n            }, x * 1000);\n        }\n        close(i);\n    }\n}\nx();\n</pre></br><p><strong>Explain:</strong> For each iteration, when the <code>close</code> function is called, it creates a new local execution context. By the time the <code>setTimeout</code> callbacks execute, each one has its own separate copy of <code>i</code> (passed as <code>x</code>). Therefore, the result will be <code>1 2 3 4 5</code>.</p>",
                "subjectId": 7,
                "sectionId": 56,
                "subSectionId": -1,
                "contentId": 163,
                "text": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">Explain the setTimeout in clouser.</span></p>"
            }
        ]
    },
    {
        "name": "<p><strong>Hoisting</strong></p>",
        "subjectId": 7,
        "sectionId": 57,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "<p>In JavaScript, <strong>hoisting</strong> is a phenomenon in which <strong>variable and function declarations</strong> to the top of their scope <strong>before execution</strong>.</p></br><p>The main benefit of <strong>hoisting </strong>is that it allows us to use functions before they are defined, enabling a <strong>top-down code structure</strong>. It also ensures <strong>variable declarations </strong>exist in <strong>memory </strong>before <strong>execution</strong>. <strong>Function hoisting</strong> especially improves <strong>code readability</strong> and <strong>organization</strong>.</p></br><p>The <strong>disadvantage </strong>of <strong>hoisting </strong>is that it can create confusing behavior. <strong>Variables </strong>declared with var become <strong>undefined </strong>instead of <strong>throwing errors</strong>, <strong>leading to bugs</strong>. Also, <strong>function expressions</strong> and <strong>arrow functions</strong> are not <strong>hoisted</strong>, which causes <strong>runtime errors</strong>. <strong>Let </strong>and <strong>const </strong>are <strong>hoisted </strong>but in a <strong>Temporal Dead Zone</strong>, making their behavior confusing too.</p>",
                "subjectId": 7,
                "sectionId": 57,
                "subSectionId": -1,
                "contentId": 164,
                "text": "<p>What is Hoisting in JavaScript?</p>"
            },
            {
                "description": "<p>The <strong>Temporal Dead Zone (TDZ)</strong> is the period between when a <code><strong>let</strong></code> or <code><strong>const</strong></code> variable is <strong>hoisted</strong> (memory allocated) and when it is <strong>initialized</strong> at its <strong>declaration line</strong>.</p><p> During this period, accessing the variable will throw a <strong>ReferenceError</strong>.</p>",
                "subjectId": 7,
                "sectionId": 57,
                "subSectionId": -1,
                "contentId": 165,
                "text": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">What is the Temporal Dead Zone?</span></p>"
            }
        ]
    },
    {
        "name": "<p><strong>Promise and async/await</strong></p>",
        "subjectId": 7,
        "sectionId": 58,
        "subSectionId": -1,
        "subSections": [
            {
                "name": "<p><strong>async/await</strong></p>",
                "subjectId": 7,
                "sectionId": 58,
                "subSectionId": 59,
                "subSections": [],
                "contents": [
                    {
                        "description": "<p><strong>async/await</strong> is a feature in JavaScript (introduced in ES8) that makes working with asynchronous code <strong>easier</strong>, <strong>cleaner</strong>, and <strong>more readable</strong>.</p></br><p>It is basically <strong>a cleaner way to use Promises</strong>.</p></br><p><strong>async keyword: </strong>When you add <strong>async</strong> before a function, that function always returns a <strong>Promise</strong>.</p><pre data-language=\"plain\">\nasync function test() {\n  return &quot;Hello&quot;;\n}\n\ntest().then(res =&gt; console.log(res)); \n</pre></br><p><strong>await keyword: </strong><code>await</code> is used <strong>inside async functions</strong> only. It <strong>pauses execution</strong> until a Promise is resolved.</p><pre data-language=\"plain\">\nasync function getData() {\n  const result = await fetchData(); // waits here\n  console.log(result);\n}\n</pre>",
                        "subjectId": 7,
                        "sectionId": 58,
                        "subSectionId": 59,
                        "contentId": 166,
                        "text": "<p>What is async/await?</p>"
                    }
                ]
            }
        ],
        "contents": [
            {
                "description": "<p>A <strong>Promise</strong> in <strong>JavaScript</strong> is an <strong>object</strong> that represents the eventual <strong>success</strong> or <strong>failure</strong> of an <strong>asynchronous operation</strong>. It has three <strong>states</strong>: <strong>Pending</strong>, <strong>Fulfilled</strong>, and <strong>Rejected</strong>.</p></br><p><strong>Promises</strong> provide a structured way to write <strong>asynchronous code</strong> using <code><strong>.then()</strong></code> for <strong>success</strong> and <code><strong>.catch()</strong></code> for <strong>error handling</strong>.</p></br><p><strong>Pending</strong> state is the <strong>initial state</strong>. The <strong>operation</strong> is still ongoing, and the <strong>result</strong> is not yet available.</p><p> In the <strong>Fulfilled</strong> state, the <strong>asynchronous operation</strong> completes <strong>successfully</strong> and returns a <strong>result</strong> (via <code><strong>.then()</strong></code>).</p><p> In the <strong>Rejected</strong> state, the <strong>asynchronous operation</strong> <strong>fails</strong> and returns an <strong>error</strong> (via <code><strong>.catch()</strong></code>).</p>",
                "subjectId": 7,
                "sectionId": 58,
                "subSectionId": -1,
                "contentId": 167,
                "text": "<p>What are Promises in JavaScript?</p>"
            },
            {
                "description": "<p><strong>Promise chaining</strong> is a <strong>technique</strong> where we attach multiple <code><strong>.then()</strong></code> calls to a <strong>Promise</strong> so that <strong>asynchronous operations</strong> are executed in <strong>sequence</strong>, one after the other. Each <code><strong>.then()</strong></code> can return a <strong>value</strong> or another <strong>Promise</strong>.</p></br><p><strong>Example 1:</strong></p></br><pre data-language=\"plain\">\nconst fetchNumber = () =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; resolve(5), 1000);\n  });\n};\n\nfetchNumber()\n  .then(num =&gt; {\n    console.log(&quot;First then:&quot;, num); // 5\n    return num * 2;\n  })\n  .then(num =&gt; {\n    console.log(&quot;Second then:&quot;, num); // 10\n    return num + 3;\n  })\n  .then(num =&gt; {\n    console.log(&quot;Third then:&quot;, num); // 13\n  })\n  .catch(err =&gt; {\n    console.error(&quot;Error:&quot;, err);\n  });\n</pre></br><p><strong>Example 2:</strong></p></br><pre data-language=\"plain\">\nconst fetchData = (id) =&gt; {\n    return new Promise((resolve) =&gt; {\n        setTimeout(() =&gt; resolve({id: id, user: &#39;User &#39; + id}));\n    });\n};\n\nfetchData(1).then(user =&gt; {\n   console.log(&quot;User fetched:&quot;, user); // User fetched: { id: 1, user: &#39;User 1&#39; }\n   return fetchData(user.id + 1);\n})\n.then(user =&gt; {\n    console.log(&quot;Next user fetched:&quot;, user); // Next user fetched: { id: 2, user: &#39;User 2&#39; }\n});\n</pre></br>",
                "subjectId": 7,
                "sectionId": 58,
                "subSectionId": -1,
                "contentId": 168,
                "text": "<p>Can you explain the Promise chain?</p>"
            },
            {
                "description": "<p><strong>Parallel Promises</strong>: There are following <strong>methods</strong> to run <strong>Promises</strong> in <strong>parallel</strong>:</p><ul><li><strong>Promise.all()</strong>: Waits for <strong>all promises</strong> to <strong>fulfill</strong> or <strong>reject immediately</strong> on any <strong>failure</strong>.</li><li><strong>Promise.allSettled()</strong>: Waits for <strong>all promises</strong>, regardless of <strong>success/failure</strong>.</li><li><strong>Promise.race()</strong>: <strong>Resolves/rejects</strong> as soon as the <strong>first promise</strong> settles.</li><li><strong>Promise.any()</strong>: <strong>Resolves</strong> when <strong>any one promise</strong> fulfills; <strong>rejects</strong> only if <strong>all fail</strong>.</li></ul></br>",
                "subjectId": 7,
                "sectionId": 58,
                "subSectionId": -1,
                "contentId": 169,
                "text": "<p>Can you explain Promise APIs | all, allSettled, race, any</p>"
            },
            {
                "description": "<p><strong>Callbacks </strong>execute an <strong>async function</strong> by passing another function as an <strong>argument</strong>, but they suffer from <strong>callback hell</strong>, <strong>poor error handling</strong>, and <strong>inversion of control</strong>. <strong>Promises </strong>solve these issues by providing a<strong> cleaner chainable structure, centralized error handling, and better control </strong>over async flow with <code>.then()</code>, <code>.catch()</code>, and <code>.finally()</code>.</p>",
                "subjectId": 7,
                "sectionId": 58,
                "subSectionId": -1,
                "contentId": 170,
                "text": "<p>How do Promises differ from callbacks?</p>"
            },
            {
                "description": "<pre data-language=\"plain\">\n// Creating a Promise that resolves after 2 seconds\n\nconst myPromise = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    const success = true; // change to false to test rejection\n    if (success) {\n      resolve(&#39;Operation successful!&#39;);\n    } else {\n      reject(&#39;Operation failed!&#39;);\n    }\n  }, 2000);\n});\n\n// Using the Promise\n\nmyPromise\n  .then((message) =&gt; {\n    console.log(message);  // Runs if resolved\n  })\n  .catch((error) =&gt; {\n    console.error(error);  // Runs if rejected\n  });\n</pre>",
                "subjectId": 7,
                "sectionId": 58,
                "subSectionId": -1,
                "contentId": 171,
                "text": "<p>Can you write a simple example of creating and using a Promise?</p>"
            },
            {
                "description": "<p><strong>Promises </strong>provide <strong>asynchronous operations</strong> using <code>.then()</code> and <code>.catch()</code>, while <strong>async/await</strong> makes <strong>asynchronous </strong>code look <strong>synchronous </strong>and easier to read. <strong>Error handling</strong> and <strong>debugging </strong>are simpler with <strong>async/await</strong>.</p>",
                "subjectId": 7,
                "sectionId": 58,
                "subSectionId": -1,
                "contentId": 172,
                "text": "<p>What is difference between <strong>async/await</strong> and <strong>Promises</strong>?</p>"
            },
            {
                "text": "<p>What is difference between <strong>Promises </strong>and <strong>Observables</strong>?</p>",
                "sectionId": 58,
                "subSectionId": -1,
                "subjectId": 7,
                "contentId": 402,
                "description": "<p>A <strong>Promise </strong>handles a single async value and executes immediately, while an <strong>Observable </strong>can handle multiple values over time, is lazy, cancellable, and supports <strong>powerful RxJS operators</strong>. <strong>Angular </strong>uses <strong>Observables </strong>for <strong>most async tasks</strong> because they are more <strong>flexible </strong>and <strong>scalable</strong>.</p>"
            }
        ]
    },
    {
        "name": "<p><strong>Arrow function</strong></p>",
        "subjectId": 7,
        "sectionId": 60,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "<p><strong>Arrow functions </strong>are a <strong>shorter syntax</strong> for writing functions in <strong>JavaScript </strong>and they don‚Äôt have their own <code>this</code>. They inherit <code>this</code> from their <strong>lexical scope</strong>, making them very useful in <strong>Angular </strong>for <strong>callbacks</strong>, <strong>RxJS</strong>, and <strong>event handlers</strong>.</p></br><pre data-language=\"plain\">\nconst add = (a, b) =&gt; a + b;\n</pre>",
                "subjectId": 7,
                "sectionId": 60,
                "subSectionId": -1,
                "contentId": 173,
                "text": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">What are arrow functions in JavaScript?</span></p>"
            },
            {
                "description": "<p><strong>Arrow functions</strong> are a <strong>shorter syntax</strong> for functions and inherit <code>this</code> from their surrounding scope. Unlike <strong>regular functions</strong>, they do not have their own <code>this</code> or <code>arguments</code>, cannot be used as <strong>constructors</strong>, and are not hoisted if defined as expressions. They are widely used in <strong>Angular </strong>for <strong>callbacks </strong>and <strong>event handlers</strong> due to their <strong>lexical </strong><code>this</code> behavior.</p></br><p>A <strong>regular function</strong> can be used as a <strong>constructor</strong> with the <code><strong>new</strong></code> keyword that creates <strong>instances</strong>, whereas an <strong>arrow function</strong> cannot be used as a <strong>constructor</strong>.</p></br><pre data-language=\"plain\">\n// Correct: Regular function as constructor\nfunction Person(name) {\n  this.name = name;\n}\nconst p = new Person(&quot;Vivek&quot;);\nconsole.log(p.name); // &quot;Vivek&quot;\n</pre></br><pre data-language=\"plain\">\n// ‚ùå Incorrect: Arrow function cannot be used as constructor\nconst PersonArrow = (name) =&gt; {\n  this.name = name;\n};\nconst p2 = new PersonArrow(&quot;Vivek&quot;); // TypeError\n</pre></br><p><strong>Notes: </strong></p><p><strong>1.</strong> <code>arguments</code> is an <strong>array-like object</strong> available inside <strong>regular functions</strong>. It contains all the arguments passed to that function, regardless of the number of parameters defined.</p>",
                "subjectId": 7,
                "sectionId": 60,
                "subSectionId": -1,
                "contentId": 174,
                "text": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">How do arrow function differ from regular functions?</span></p>"
            },
            {
                "text": "<p>Explain the output:</p><pre data-language=\"plain\">\nconst obj = {\n  value: 10,\n  regularFunc: function() {\n    console.log(this.value);\n  },\n  arrowFunc: () =&gt; {\n    console.log(this.value);\n  }\n};\n\nobj.regularFunc(); // 10\nobj.arrowFunc();   // undefined\n</pre></br>",
                "sectionId": 60,
                "subSectionId": -1,
                "subjectId": 7,
                "contentId": 404,
                "description": "<pre data-language=\"plain\">\nconst obj = {\n  value: 10,\n  regularFunc: function() {\n    console.log(this.value);\n  },\n  arrowFunc: () =&gt; {\n    console.log(this.value);\n  }\n};\n\nobj.regularFunc(); // 10\nobj.arrowFunc();   // undefined\n</pre></br><p>Regular functions have dynamic <code>this</code> determined by how they are called, whereas arrow functions inherit <code>this</code> lexically from their surrounding scope. That‚Äôs why a regular function accesses the object‚Äôs property but an arrow function inside the same object does not.</p>"
            }
        ]
    },
    {
        "name": "<p><strong>map(), forEach(), filter() and reduce()</strong></p>",
        "subjectId": 7,
        "sectionId": 61,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "<p>const numbers = [1, 2, 3];</p></br><p><strong>map():</strong> Transforms each element in an array and returns a new array of the same length. Does not mutate the original array.</p></br><pre data-language=\"plain\">\nconst doubled = numbers.map(num =&gt; num * 2);\nconsole.log(doubled); // [2, 4, 6]\n</pre></br><p><strong>forEach():</strong> Iterates over each element in an array to perform an operation. Always returns undefined. Does not mutate the original array (unless done manually).</p></br><pre data-language=\"plain\">\nnumbers.forEach(num =&gt; console.log(num * 2));\n// Output: 2, 4, 6 (just logs, no returned array)\n</pre></br><p><strong>filter():</strong> Returns a new array containing only the elements that satisfy the provided condition (true). Does not mutate the original array.</p></br><pre data-language=\"plain\">\nconst even = numbers.filter(num =&gt; num % 2 === 0);\nconsole.log(even); // [2]\n</pre></br><p><strong>reduce():</strong> Reduces the array to a single value (which can be a number, string, object, array, etc.) based on the accumulator logic. Does not mutate the original array.</p></br><pre data-language=\"plain\">\nconst sum = numbers.reduce((acc, num) =&gt; acc + num, 0);\nconsole.log(sum); // 6\n</pre>",
                "subjectId": 7,
                "sectionId": 61,
                "subSectionId": -1,
                "contentId": 175,
                "text": "<p>What is the <strong>difference</strong> between <strong>map()</strong>, <strong>forEach()</strong>, <strong>filter()</strong>, and <strong>reduce()</strong> in <strong>JavaScript</strong>? Can you give a <strong>small example</strong> for each?</p>"
            }
        ]
    },
    {
        "name": "<p><strong>Currying</strong></p>",
        "subjectId": 7,
        "sectionId": 62,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "<p><strong>Currying</strong> in <strong>JavaScript</strong> is the process of <strong>transforming a function</strong> with <strong>multiple arguments</strong> into a <strong>sequence of functions</strong>, each taking <strong>one argument at a time</strong>.</p></br><pre data-language=\"plain\">\n// Currying using Closure\nfunction multiply(a) {\n  return function(b) {\n    return a * b;\n  };\n}\n// Usage\nconst multiplyByTwo = multiply(2);\nconsole.log(multiplyByTwo(5)); // Output: 10\nconst multiplyByFive = multiply(5);\nconsole.log(multiplyByFive(5)); // Output: 25\n</pre></br><pre data-language=\"plain\">\n// Currying using Bind method\nfunction multiply(a, b) {\n    return a * b;\n}\n// Usage\nconst multiplyByTwo = multiply.bind(this, 2);\nconsole.log(multiplyByTwo(5)); // Output: 10\nconst multiplyByFive = multiply.bind(null, 5);\nconsole.log(multiplyByFive(5)); // Output: 25\n// the bind method: The first argument is always the ‚Äòthis‚Äô context for the function being bound.\n// Since this is not used in the function, we can pass null as the ‚Äòthis‚Äô context.\n</pre></br>",
                "subjectId": 7,
                "sectionId": 62,
                "subSectionId": -1,
                "contentId": 176,
                "text": "<p>What is <strong>currying </strong>in JavaScript?</p>"
            },
            {
                "description": "<pre data-language=\"plain\">\nlet sum = function(a) {\n    return function (b) {\n        if(b) {\n            return sum(a+b);\n        } else {\n            return a;\n        }\n    };\n};\nconsole.log(sum(1)(2)(3)(4)(5)()); // 15\nconsole.log(5); // 5\nconsole.log(sum(2)(4)(5)(8)()); // 19\n</pre></br><pre data-language=\"plain\">\nlet sum = a =&gt; b =&gt; b? sum(a+b) : a;\nconsole.log(sum(1)(2)(3)(4)(5)()); // 15\nconsole.log(5); // 5\nconsole.log(sum(2)(4)(5)(8)()); // 19\n</pre>",
                "subjectId": 7,
                "sectionId": 62,
                "subSectionId": -1,
                "contentId": 177,
                "text": "<p>sum(1)(2)(3)(4)..( n)()</p>"
            }
        ]
    },
    {
        "name": "<p><strong>Event Handlers, Web Storage API (localStorage, sessionStorage)</strong></p>",
        "sectionId": 114,
        "subSectionId": -1,
        "subjectId": 7,
        "contents": [],
        "subSections": [
            {
                "name": "<p><strong>Event Handlers</strong></p>",
                "sectionId": 114,
                "subSectionId": 115,
                "subjectId": 7,
                "contents": [
                    {
                        "text": "<p>What is <strong>Event Handlers</strong>?</p>",
                        "sectionId": 114,
                        "subSectionId": 115,
                        "subjectId": 7,
                        "contentId": 403,
                        "description": "<p><strong>Event handlers</strong> are functions that run in response to user actions or browser events.</p><p>Examples of events:</p><ul><li>Click</li><li>Input</li><li>Key press</li><li>Mouse over</li><li>Scroll</li><li>Submit</li><li>Load</li></ul><p>When an event happens, the handler function executes.</p></br></br>"
                    }
                ],
                "subSections": []
            },
            {
                "name": "<p><strong>Web Storage API</strong></p>",
                "sectionId": 114,
                "subSectionId": 135,
                "subjectId": 7,
                "contents": [
                    {
                        "text": "<p>What is difference between  <code><strong>localStorage</strong></code><strong> </strong>and  <code><strong>sessionStorage</strong></code><strong> </strong>?</p>",
                        "sectionId": 114,
                        "subSectionId": 135,
                        "subjectId": 7,
                        "contentId": 427,
                        "description": "<p>Both <code>localStorage</code> and <code>sessionStorage</code> are part of the <strong>Web Storage API</strong> and are used to store data in the browser as <strong>key‚Äìvalue pairs</strong>.</p></br><p><strong>Data Persistence:</strong></p><p><strong>localStorage</strong></p><ul><li>Data persists even after the browser is closed and reopened.</li></ul><p><strong>sessionStorage</strong></p><ul><li>Data is cleared when the <strong>tab or browser session is closed</strong>.</li></ul></br><p><strong>Scope:</strong></p><p><strong>localStorage</strong></p><ul><li>Shared across <strong>all tabs and windows</strong> of the same origin.</li><li>Shared between original tab and duplicate tab</li></ul><p><strong>sessionStorage</strong></p><ul><li>Scoped to a <strong>single browser tab</strong>.</li><li>Opening the same app in a new tab creates a <strong>new session</strong>.</li><li>Data is copied initially in some browsers, but after that they are <strong>independent</strong></li></ul></br></br><p><strong>Storage Limit:</strong></p><p>Both typically allow around <strong>5‚Äì10 MB</strong> (browser-dependent).</p></br><p><strong>Security:</strong></p><ul><li>Both are accessible via JavaScript</li><li><strong>Not secure against XSS attacks</strong></li><li>Do <strong>not</strong> store sensitive information like passwords</li></ul></br><pre data-language=\"plain\">\nfromEvent&lt;StorageEvent&gt;(window, &#39;storage&#39;).subscribe(d =&gt; {\n      console.log(&#39;fromEvent: &#39;, d);\n});\n\nwindow.addEventListener(&#39;storage&#39;, (event) =&gt; {\n      console.log(&#39;addEventListener: &#39;, event);\n});\n</pre>"
                    }
                ],
                "subSections": []
            }
        ]
    },
    {
        "name": "<p><strong>Built-in Methods</strong></p>",
        "subjectId": 7,
        "sectionId": 63,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "<p><strong>Math</strong> is a <strong>built-in object</strong> in JavaScript</p><p>that is used to <strong>perform mathematical operations</strong>, such as:</p></br><table style=\"border: 1px solid #000;\"><tbody><tr><td data-row=\"2\"><code>Math.floor()</code></td><td data-row=\"2\">Round <strong>down</strong></td><td data-row=\"2\"><code>Math.floor(4.9)</code> ‚Üí <code>4</code></td></tr><tr><td data-row=\"3\"><code>Math.ceil()</code></td><td data-row=\"3\">Round <strong>up</strong></td><td data-row=\"3\"><code>Math.ceil(4.1)</code> ‚Üí <code>5</code></td></tr><tr><td data-row=\"4\"><code>Math.round()</code></td><td data-row=\"4\">Round to <strong>nearest integer</strong></td><td data-row=\"4\"><code>Math.round(4.5)</code> ‚Üí <code>5</code></td></tr><tr><td data-row=\"5\"><code>Math.trunc()</code></td><td data-row=\"5\">Remove decimal part</td><td data-row=\"5\"><code>Math.trunc(4.9)</code> ‚Üí <code>4</code></td></tr><tr><td data-row=\"6\"><code>Math.random()</code></td><td data-row=\"6\">Generate random number (0‚Äì1)</td><td data-row=\"6\"><code>Math.random()</code> ‚Üí <code>0.54</code></td></tr><tr><td data-row=\"7\"><code>Math.max()</code></td><td data-row=\"7\">Find maximum value</td><td data-row=\"7\"><code>Math.max(5,10,2)</code> ‚Üí <code>10</code></td></tr><tr><td data-row=\"8\"><code>Math.min()</code></td><td data-row=\"8\">Find minimum value</td><td data-row=\"8\"><code>Math.min(5,10,2)</code> ‚Üí <code>2</code></td></tr><tr><td data-row=\"9\"><code>Math.sqrt()</code></td><td data-row=\"9\">Square root</td><td data-row=\"9\"><code>Math.sqrt(9)</code> ‚Üí <code>3</code></td></tr><tr><td data-row=\"10\"><code>Math.pow()</code></td><td data-row=\"10\">Power</td><td data-row=\"10\"><code>Math.pow(2,3)</code> ‚Üí <code>8</code></td></tr></tbody></table>",
                "subjectId": 7,
                "sectionId": 63,
                "subSectionId": -1,
                "contentId": 178,
                "text": "<p>What is Math?</p>"
            },
            {
                "description": "<table style=\"border: 1px solid #000;\"><tbody><tr><td data-row=\"1\">Method Returns / Does Includes inherited?</td></tr><tr><td data-row=\"2\"> <code>Object.keys()</code></td><td data-row=\"2\">Array of keys</td><td data-row=\"2\">‚ùå</td></tr><tr><td data-row=\"3\"><code>Object.values()</code></td><td data-row=\"3\">Array of values</td><td data-row=\"3\">‚ùå</td></tr><tr><td data-row=\"4\"><code>Object.entries()</code></td><td data-row=\"4\">Array of [key, value]</td><td data-row=\"4\">‚ùå</td></tr><tr><td data-row=\"5\"><code>Object.assign()</code></td><td data-row=\"5\">Copies props to target</td><td data-row=\"5\">‚ùå</td></tr><tr><td data-row=\"6\"><code>Object.create()</code></td><td data-row=\"6\">Creates new object with prototype</td><td data-row=\"6\">‚Äî</td></tr><tr><td data-row=\"7\"><code>Object.freeze()</code></td><td data-row=\"7\">Makes object immutable</td><td data-row=\"7\">‚Äî</td></tr><tr><td data-row=\"8\"><code>Object.seal()</code></td><td data-row=\"8\">Prevents add/remove, allows modify</td><td data-row=\"8\">‚Äî</td></tr><tr><td data-row=\"9\"><code>Object.hasOwn()</code></td><td data-row=\"9\">Checks own property</td><td data-row=\"9\">‚ùå</td></tr><tr><td data-row=\"10\"><code>Object.getOwnPropertyNames()</code></td><td data-row=\"10\">All own (even non-enumerable)</td><td data-row=\"10\">‚ùå</td></tr><tr><td data-row=\"11\"><code>Object.getPrototypeOf()</code></td><td data-row=\"11\">Gets prototype</td><td data-row=\"11\">‚Äî</td></tr><tr><td data-row=\"12\"><code>Object.fromEntries()</code></td><td data-row=\"12\">Converts [key, value] array ‚Üí object</td><td data-row=\"12\">‚Äî</td></tr></tbody></table></br>",
                "subjectId": 7,
                "sectionId": 63,
                "subSectionId": -1,
                "contentId": 179,
                "text": "<p>What is Object built-in method?</p>"
            },
            {
                "description": "<pre data-language=\"plain\">\n&lt;input type=&quot;text&quot; (input)=&quot;onInputChangeNumber($event)&quot;/&gt;\n\n// Only Numeric Validation\nonInputChangeNumber(event: any) {\n     const initial = event.target.value;\n     event.target.value = initial.replace(/[^0-9]/g, &#39;&#39;);\n}\n\n// Only Letters Validation\nevent.target.value = initial.replace(/[^a-zA-Z]/g, &#39;&#39;);\n\n// Allow Letters + Space\nevent.target.value = initial.replace(/[^a-zA-Z ]/g, &#39;&#39;);\n\n// Allow Letters + Space + Dot\nevent.target.value = initial.replace(/[^a-zA-Z .]/g, &#39;&#39;);\n\n// Allow Letters + Number\nevent.target.value = initial.replace(/[^a-zA-Z 0-9]/g, &#39;&#39;);\n</pre></br>",
                "subjectId": 7,
                "sectionId": 63,
                "subSectionId": -1,
                "contentId": 180,
                "text": "<p>event + Regex</p>"
            },
            {
                "description": "<pre data-language=\"true\">\n// Only Numeric Validation:\nValidators.pattern(/^[0-9]+$/)\n\n// Only Character Validation:\nValidators.pattern(/^[a-zA-Z]*$/)\n\n// Character + Space + dot Validation:\nValidators.pattern(/^[a-zA-Z .]*$/)\n</pre>",
                "subjectId": 7,
                "sectionId": 63,
                "subSectionId": -1,
                "contentId": 181,
                "text": "<p>Validators + Regex</p>"
            }
        ]
    },
    {
        "name": "<p><strong>Coding: Find Result and Explain</strong></p>",
        "subjectId": 7,
        "sectionId": 64,
        "subSectionId": -1,
        "subSections": [
            {
                "name": "<p><strong>Find Result and explain it.</strong></p>",
                "subjectId": 7,
                "sectionId": 64,
                "subSectionId": 65,
                "subSections": [],
                "contents": [
                    {
                        "text": "<p><strong>Promises </strong>and <strong>Settimeout </strong>related coding questions.</p>",
                        "sectionId": 64,
                        "subSectionId": 65,
                        "subjectId": 7,
                        "contentId": 430,
                        "description": "<pre data-language=\"plain\">\n// Complex Question 1\n\nconsole.log(&quot;A&quot;);\n\nsetTimeout(() =&gt; {\n  console.log(&quot;B&quot;);\n}, 0);\n\nPromise.resolve()\n  .then(() =&gt; {\n    console.log(&quot;C&quot;);\n    return Promise.resolve(&quot;D&quot;);\n  })\n  .then(res =&gt; console.log(res));\n\nconsole.log(&quot;E&quot;);\n\n\n\n\n\n\n\n\n\n// Output::\nA\nE\nC\nD\nB\n</pre></br><pre data-language=\"plain\">\n// Complex Question 2\n\nconsole.log(&quot;Start&quot;);\n\nsetTimeout(() =&gt; {\n  console.log(&quot;Timeout 1&quot;);\n\n  Promise.resolve().then(() =&gt; {\n    console.log(&quot;Promise inside timeout&quot;);\n  });\n}, 0);\n\nPromise.resolve().then(() =&gt; {\n  console.log(&quot;Promise 1&quot;);\n});\n\nconsole.log(&quot;End&quot;);\n\n\n\n\n\n\n\n\n\n// Output:\nStart\nEnd\nPromise 1\nTimeout 1\nPromise inside timeout\n</pre></br><pre data-language=\"plain\">\n// Complex Question 3\n\nconsole.log(&quot;1&quot;);\n\nPromise.resolve().then(() =&gt; {\n  console.log(&quot;2&quot;);\n\n  Promise.resolve().then(() =&gt; {\n    console.log(&quot;3&quot;);\n  });\n});\n\nPromise.resolve().then(() =&gt; {\n  console.log(&quot;4&quot;);\n});\n\nconsole.log(&quot;5&quot;);\n\n\n\n\n\n\n\n\n\nOutput:\n1\n5\n2\n4\n3\n</pre></br><pre data-language=\"plain\">\n// Complex Question 4\n\nasync function test() {\n  console.log(&quot;A&quot;);\n\n  await Promise.resolve();\n\n  console.log(&quot;B&quot;);\n}\n\nconsole.log(&quot;C&quot;);\ntest();\nconsole.log(&quot;D&quot;);\n\n\n\n\n\n\n\n\n\nOutput:\nC\nA\nD\nB\n</pre></br><pre data-language=\"plain\">\n// Complex Question 5 \n\nconsole.log(&quot;Start&quot;);\n\nnew Promise((resolve) =&gt; {\n  console.log(&quot;Inside Promise&quot;);\n  resolve();\n}).then(() =&gt; {\n  console.log(&quot;Then block&quot;);\n});\n\nconsole.log(&quot;End&quot;);\n\n\n\n\n\n\n\n\n\n// Output:\nStart\nInside Promise\nEnd\nThen block\n</pre></br><pre data-language=\"plain\">\n// Complex Question 6\n\nPromise.resolve().then(() =&gt; {\n  console.log(&quot;Microtask&quot;);\n\n  setTimeout(() =&gt; {\n    console.log(&quot;Macrotask inside microtask&quot;);\n  }, 0);\n});\n\nsetTimeout(() =&gt; {\n  console.log(&quot;Macrotask&quot;);\n}, 0);\n\n\n\n\n\n\n\n\n\n// Output:\nMicrotask\nMacrotask\nMacrotask inside microtask\n</pre></br><pre data-language=\"plain\">\n// Complex Question 7\n\nconsole.log(&quot;Start&quot;);\n\nsetTimeout(() =&gt; console.log(&quot;Timeout&quot;), 0);\n\nfor (let i = 0; i &lt; 1e9; i++) {}\n\nconsole.log(&quot;End&quot;);\n\n\n\n\n\n\n\n\n\n// Output:\nStart\nEnd\nTimeout\n</pre></br><pre data-language=\"plain\">\n// Complex Question 8\n\nconsole.log(&quot;Init&quot;);\n\nPromise.resolve().then(() =&gt; {\n  console.log(&quot;API response&quot;);\n});\n\nsetTimeout(() =&gt; {\n  console.log(&quot;Change detection&quot;);\n}, 0);\n\n\n\n\n\n\n\n\n\n// Output:\nInit\nAPI response\nChange detection\n</pre>"
                    },
                    {
                        "description": "<p>When this code executes, JavaScript first runs the synchronous code, so it immediately prints <strong>Start</strong>. Then <code>setTimeout</code> is registered with the Web APIs, and its callback is placed in the macrotask queue, but it will execute only after the call stack becomes empty. Next, the Promise is created and resolved immediately, but the <code>then</code> callback, if present, would be queued in the microtask queue. Since the microtask queue has higher priority than the macrotask queue, Promise callbacks execute before <code>setTimeout</code>. However, in this code, there is no <code>then</code> attached to the Promise, so nothing gets printed from it. Finally, once the call stack is empty and there are no microtasks to run, the <code>setTimeout</code> callback executes and prints <strong>Settimeout executed</strong>.</p>",
                        "subjectId": 7,
                        "sectionId": 64,
                        "subSectionId": 65,
                        "contentId": 182,
                        "text": "<pre data-language=\"plain\">\nconsole.log(&quot;Start&quot;);\n\nsetTimeout(() =&gt; {\n    console.log(&quot;Settimeout executed&quot;); \n});\n\nconst myPromise = new Promise((resolve) =&gt; {\n    resolve(&quot;Resolve Promise&quot;); \n});\n\nmyPromise.then((res) =&gt; {\n    console.log(res); \n});\n\nconsole.log(&quot;End&quot;);\n</pre>"
                    },
                    {
                        "description": "<p>When I call <code>details.regularFn()</code>, it prints <strong>Vivek</strong> because <code>regularFn</code> is a normal JavaScript function. In JavaScript, the value of <code>this</code> for a regular function depends on how the function is called. Since it is called using the <code>details</code> object, <code>this</code> refers to the <code>details</code> object itself, so <code>this.name</code> resolves to Vivek.</p><p>However, when I call <code>details.arrowFn()</code>, it prints <strong>undefined</strong>. This is because arrow functions do not have their own <code>this</code>. Instead, they inherit <code>this</code> from their surrounding lexical scope. In this case, the surrounding scope is the global scope, not the <code>details</code> object. Since there is no <code>name</code> property in the global scope, <code>this.name</code> becomes undefined.</p>",
                        "subjectId": 7,
                        "sectionId": 64,
                        "subSectionId": 65,
                        "contentId": 183,
                        "text": "<pre data-language=\"plain\">\nconst details = {\n  name: &quot;Vivek&quot;,\n  regularFn: function() {\n      return this.name;\n  },\n  arrowFn: () =&gt; {\n      return this.name;\n  },\n};\n\nconsole.log(details.regularFn());\nconsole.log(details.arrowFn());\n\n</pre>"
                    },
                    {
                        "description": "<p>When this code runs, it prints undefined, not an error. This happens because of <strong>JavaScript </strong>hoisting. During the <strong>memory creation phase</strong>, the variable declared with var is hoisted to the top of its scope and is initialized with the value <strong>undefined</strong>. So when <strong>console.log(name)</strong> executes, the variable name already exists in memory but has not yet been assigned the value<strong> &quot;Vivek&quot;</strong>. The assignment happens afterward. That‚Äôs why the output is <strong>undefined </strong>instead of <strong>Vivek</strong>.</p>",
                        "subjectId": 7,
                        "sectionId": 64,
                        "subSectionId": 65,
                        "contentId": 184,
                        "text": "<pre data-language=\"plain\">\nconsole.log(name);\nvar name = &quot;Vivek&quot;;\n</pre>"
                    },
                    {
                        "description": "<p>When this code runs, it throws a <strong>ReferenceError</strong>. Even though <code>const</code> declarations are hoisted, they are not initialized during the memory creation phase. The variable stays in what is called the <strong>Temporal Dead Zone</strong> from the start of the scope until the declaration line is executed. So when <code>console.log(name)</code> tries to access <code>name</code> before it is declared, JavaScript does not allow it and throws a <strong>ReferenceError</strong>. This is different from <code>var</code>, which gets initialized with <strong>undefined</strong>.</p>",
                        "subjectId": 7,
                        "sectionId": 64,
                        "subSectionId": 65,
                        "contentId": 185,
                        "text": "<pre data-language=\"plain\">\nconsole.log(name);\nconst name = &quot;Vivek&quot;;\n</pre>"
                    }
                ]
            }
        ],
        "contents": []
    },
    {
        "name": "<p><strong>Coding: Complete Implementation</strong></p>",
        "subjectId": 7,
        "sectionId": 66,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "<pre data-language=\"plain\">\nconst counter = () =&gt; {\n    let count = 0;\n    return {\n        increment: () =&gt; {\n            count++;\n            console.log(count);\n        },\n        decrement: function() {\n            count--;\n            console.log(count);\n        }  \n    };\n};\n\nconst counterControl = counter();\ncounterControl.increment();\ncounterControl.decrement();\n</pre>",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 186,
                "text": "<pre data-language=\"plain\">\nconst counter = () =&gt; {\n    let count = 0;\n    return ...;\n};\n\nconst counterControl = counter();\ncounterControl.increment();\ncounterControl.decrement();\n</pre>"
            },
            {
                "description": "<pre data-language=\"plain\">\nfunction factorial(n) {\n    if (n &lt; 0) return -1; // Factorial not defined for negative numbers\n    let result = 1;\n    for (let i = 2; i &lt;= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\nconsole.log(factorial(5)); // Output: 120\n</pre></br><pre data-language=\"plain\">\nfunction factorial(n) {\n    if (n &lt; 0) return -1;\n    if (n === 0 || n === 1) return 1;\n    return n * factorial(n - 1);\n}\n\nconsole.log(factorial(5)); // Output: 120\n</pre></br></br>",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 187,
                "text": "<p>What is a factorial, and how is it calculated?</p>"
            },
            {
                "description": "<pre data-language=\"plain\">\nlet users = [\n  { name: &#39;Alice&#39;, age: 25 },\n  { name: &#39;Bob&#39;, age: 20 },\n  { name: &#39;Charlie&#39;, age: 30 }\n];\n</pre></br><p><strong>Sort by Age (Ascending)</strong></p><pre data-language=\"plain\">\nusers.sort((a, b) =&gt; a.age - b.age);\nconsole.log(users);\n/* Output:\n[\n  { name: &#39;Bob&#39;, age: 20 },\n  { name: &#39;Alice&#39;, age: 25 },\n  { name: &#39;Charlie&#39;, age: 30 }\n]\n*/\n</pre></br><p><strong>Sort by Name (Alphabetical)</strong></p><pre data-language=\"plain\">\nusers.sort((a, b) =&gt; a.name.localeCompare(b.name));\nconsole.log(users);\n/* Output:\n[\n  { name: &#39;Alice&#39;, age: 25 },\n  { name: &#39;Bob&#39;, age: 20 },\n  { name: &#39;Charlie&#39;, age: 30 }\n]\n*/\n</pre></br></br><p><strong>Tips:</strong></p><ol><li>Always use a comparison function for numbers or custom sorting.</li><li>localeCompare is useful for string sorting with international characters.</li><li>Sorting mutates the original array; to avoid that, use array.slice().sort().</li></ol>",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 188,
                "text": "<p>What is the difference between sorting strings and numbers in JavaScript?</p>"
            },
            {
                "description": "<p>Bubble Sort repeatedly compares adjacent elements and <strong>swaps them</strong> if they are in the wrong order.</p><ul><li>Time complexity: <strong>O(n¬≤)</strong></li><li>Space complexity: <strong>O(1)</strong></li><li>Stable sort: <strong>Yes</strong></li></ul></br><pre data-language=\"plain\">\nfunction bubbleSort(arr) {\n    let n = arr.length;\n    for (let i = 0; i &lt; n - 1; i++) {\n        // Last i elements are already sorted\n        for (let j = 0; j &lt; n - i - 1; j++) {\n            if (arr[j] &gt; arr[j + 1]) {\n                // Swap arr[j] and arr[j+1]\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n    return arr;\n}\n\nlet numbers = [5, 2, 9, 1, 7];\nconsole.log(bubbleSort(numbers)); // Output: [1, 2, 5, 7, 9]\n</pre>",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 189,
                "text": "<p>Can you sort array using bubble sort?</p></br>"
            },
            {
                "description": "<pre data-language=\"plain\">\nfunction quickSort(arr) {\n    if (arr.length &lt;= 1) return arr; // Base case\n\n    const pivot = arr[arr.length - 1]; // Choose last element as pivot\n    const left = [];\n    const right = [];\n\n    for (let i = 0; i &lt; arr.length - 1; i++) {\n        if (arr[i] &lt; pivot) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n\n    // Recursively sort left and right, then combine\n    return [...quickSort(left), pivot, ...quickSort(right)];\n}\n\n// Example usage\nlet numbers = [5, 2, 9, 1, 7];\nconsole.log(quickSort(numbers)); // Output: [1, 2, 5, 7, 9]\n</pre></br>",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 190,
                "text": "<p>Can you sort array using quick sort?</p>"
            },
            {
                "description": "<p><strong>Using Set (Simplest &amp; Modern Way):</strong></p><pre data-language=\"plain\">\nlet numbers = [1, 2, 2, 3, 4, 4, 5];\n\nlet uniqueNumbers = [...new Set(numbers)];\nconsole.log(uniqueNumbers); // Output: [1, 2, 3, 4, 5]\n</pre></br><p><strong>Using filter() and indexOf():</strong></p><pre data-language=\"plain\">\nlet numbers = [1, 2, 2, 3, 4, 4, 5];\n\nlet uniqueNumbers = numbers.filter((value, index, arr) =&gt; {\n    return arr.indexOf(value) === index;\n});\n\nconsole.log(uniqueNumbers); // Output: [1, 2, 3, 4, 5]\n</pre></br><p><strong>Using Object/Map (Good for large arrays):</strong></p><pre data-language=\"plain\">\nlet numbers = [1, 2, 2, 3, 4, 4, 5];\nlet seen = {};\nlet uniqueNumbers = [];\n\nfor (let num of numbers) {\n    if (!seen[num]) {\n        uniqueNumbers.push(num);\n        seen[num] = true;\n    }\n}\n\nconsole.log(uniqueNumbers); // Output: [1, 2, 3, 4, 5]\n</pre>",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 191,
                "text": "<p>Can you remove duplicate number from array?</p>"
            },
            {
                "description": "<p><strong>Using Math.max and Math.min:</strong></p><pre data-language=\"plain\">\nlet numbers = [5, 2, 9, 1, 7];\n\nlet largest = Math.max(...numbers);\nlet smallest = Math.min(...numbers);\n\nconsole.log(&quot;Largest:&quot;, largest); // Output: 9\nconsole.log(&quot;Smallest:&quot;, smallest); // Output: 1\n</pre></br><p><strong>Using a Loop (Classic Approach)</strong></p><pre data-language=\"plain\">\nlet numbers = [5, 2, 9, 1, 7];\n\nlet largest = numbers[0];\nlet smallest = numbers[0];\n\nfor (let i = 1; i &lt; numbers.length; i++) {\n    if (numbers[i] &gt; largest) largest = numbers[i];\n    if (numbers[i] &lt; smallest) smallest = numbers[i];\n}\n\nconsole.log(&quot;Largest:&quot;, largest); // Output: 9\nconsole.log(&quot;Smallest:&quot;, smallest); // Output: 1\n</pre></br>",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 192,
                "text": "<p>Find the <strong>largest/smallest number</strong> in an array.</p>"
            },
            {
                "description": "<pre data-language=\"plain\">\nlet numbers = [5, 2, 9, 1, 7];\n\nlet largest = -Infinity;\nlet secondLargest = -Infinity;\nlet smallest = Infinity;\nlet secondSmallest = Infinity;\n\nfor (let num of numbers) {\n    // For largest and second largest\n    if (num &gt; largest) {\n        secondLargest = largest;\n        largest = num;\n    } else if (num &gt; secondLargest &amp;&amp; num !== largest) {\n        secondLargest = num;\n    }\n\n    // For smallest and second smallest\n    if (num &lt; smallest) {\n        secondSmallest = smallest;\n        smallest = num;\n    } else if (num &lt; secondSmallest &amp;&amp; num !== smallest) {\n        secondSmallest = num;\n    }\n}\n\nconsole.log(&quot;Second Largest:&quot;, secondLargest);   // Output: 7\nconsole.log(&quot;Second Smallest:&quot;, secondSmallest); // Output: 2\n</pre></br>",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 193,
                "text": "<p>Find <strong>second largest/smallest element</strong>.</p>"
            },
            {
                "description": "<pre data-language=\"plain\">\nlet str = &quot;Hello World&quot;;\n\nlet vowelsCount = 0;\nlet consonantsCount = 0;\n\n// Convert string to lowercase for easy comparison\nlet lowerStr = str.toLowerCase();\n\nfor (let char of lowerStr) {\n    if (char &gt;= &#39;a&#39; &amp;&amp; char &lt;= &#39;z&#39;) { // Consider only alphabets\n        if (&quot;aeiou&quot;.includes(char)) {\n            vowelsCount++;\n        } else {\n            consonantsCount++;\n        }\n    }\n}\n\nconsole.log(&quot;Vowels:&quot;, vowelsCount);       // Output: 3\nconsole.log(&quot;Consonants:&quot;, consonantsCount); // Output: 7\n</pre>",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 194,
                "text": "<p>Count the <strong>number of vowels/consonants</strong> in a string.</p>"
            },
            {
                "description": "<pre data-language=\"plain\">\nfunction isPerfectNumber(num) {\n    if (num &lt;= 1) return false; // 1 or negative numbers are not perfect\n\n    let sum = 0;\n    for (let i = 1; i &lt;= num / 2; i++) { // only check up to num/2\n        if (num % i === 0) {\n            sum += i;\n        }\n    }\n\n    return sum === num;\n}\n\n// Test\nconsole.log(isPerfectNumber(6));  // true\nconsole.log(isPerfectNumber(28)); // true\nconsole.log(isPerfectNumber(12)); // false\n</pre></br>",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 195,
                "text": "<p>Check if a number is a <strong>perfect number</strong>.</p>"
            },
            {
                "description": "<p><strong>Using Array.prototype.flat() (Modern &amp; Simple):</strong></p><pre data-language=\"plain\">\nlet nestedArray = [1, [2, [3, 4], 5], 6];\n\n// Use flat() with Infinity to flatten all levels\nlet flattened = nestedArray.flat(Infinity);\n\nconsole.log(flattened); // Output: [1, 2, 3, 4, 5, 6]\n</pre></br><p><strong>Using Recursion (Classic Interview Approach):</strong></p><pre data-language=\"plain\">\nconst array = [1, [2, [3, 4], 5], 6, [[[7, [8, 9, [10, 11, 12]]]]]];\n\nfunction flattenArray(nestedArray, targetArray = []) {\n    for(const item of nestedArray) {\n        if(Array.isArray(item)) {\n            flattenArray(item, targetArray);\n        } else {\n            targetArray.push(item);\n        }\n    }\n    return targetArray;\n}\nconsole.log(flattenArray(array));\n</pre>",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 196,
                "text": "<p>Implement <strong>flattening of nested arrays</strong>.</p>"
            },
            {
                "description": "<pre data-language=\"plain\">\nconst nestedObject = {\n    a: 1, \n    b: {\n        c: [1, 4, 5],\n        d: 4,\n        e: {\n            f: [1, 2, 3]\n        },\n        g: null\n    }\n}\n\nfunction flattenObj(nestedObj, targetKey = &#39;&#39;, result = {}) {\n    for(const [key, value] of Object.entries(nestedObj)) {\n        const newKey = targetKey? `${targetKey}.${key}` : key;\n        if(typeof value === &#39;object&#39; &amp;&amp; !Array.isArray(value) &amp;&amp; value !== null) {\n            flattenObj(value, newKey, result);\n        } else {\n            result[newKey] = value;\n        }\n    }\n    return result;\n}\nconsole.log(flattenObj(nestedObject));\n</pre></br>",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 197,
                "text": "<p>Implement <strong>flattening </strong>of <strong>nested object</strong>.</p>"
            },
            {
                "description": "",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 198,
                "text": "<p>Implement <strong>debounce</strong> and <strong>throttle</strong> functions.</p>"
            },
            {
                "description": "",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 199,
                "text": "<p>Write <strong>memoization</strong> function for optimization.</p>"
            },
            {
                "description": "<pre data-language=\"plain\">\nlet arr = [1, 2.5, 3/2, -4, 0.75];\n\nlet integers = arr.filter(num =&gt; Number.isInteger(num));\nlet nonIntegers = arr.filter(num =&gt; !Number.isInteger(num));\n\nconsole.log(&quot;Integers:&quot;, integers);       // [1, -4]\nconsole.log(&quot;Non-Integers:&quot;, nonIntegers); // [2.5, 1.5, 0.75]\n</pre></br>",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 200,
                "text": "<p>Find <strong>integer </strong>vs <strong>Non-Integer</strong> Rational Numbers.</p>"
            },
            {
                "description": "<pre data-language=\"plain\">\nconst data = {\n  user: {\n    name: &quot;Vivek&quot;,\n    details: {\n      age: 31,\n      city: {\n          cityName: &#39;Varanasi&#39;,\n          pin: 221112\n      },\n      phoneNumbers: [125425, 5468987, 6547526]\n    },\n  },\n  active: false,\n};\n\nfunction hasKey(nestedObj, targetKey) {\n    for(const [key, value] of Object.entries(nestedObj)) {\n        if(key === targetKey) return true;\n        \n        if(typeof value === &#39;object&#39; &amp;&amp; !Array.isArray(value) &amp;&amp; value !== null) {\n            if(hasKey(value, targetKey)) return true; \n        }\n    }\n    return false;\n}\n\nconsole.log(hasKey(data, &#39;phoneNumbers&#39;));\n</pre>",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 201,
                "text": "<p><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">Can you </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">check</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\"> if a </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">property exists</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\"> in an </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">object</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">?</span></p>"
            },
            {
                "description": "<pre data-language=\"plain\">\nconst data = {\n  user: {\n    name: &quot;Vivek&quot;,\n    details: {\n      age: 31,\n      city: {\n          cityName: &#39;Varanasi&#39;,\n          pin: 221112\n      },\n      phoneNumbers: [125425, 5468987, 6547526]\n    },\n  },\n  active: false,\n};\nfunction deepClone(nestedObj) {\n    const result = {};\n    for(const [key, value] of Object.entries(nestedObj)) {\n        if(typeof value === &#39;object&#39; &amp;&amp; !Array.isArray(value) &amp;&amp; value !== null) {\n            result[key] = deepClone(value);\n        } else {\n            result[key] = value;\n        }\n    }\n    return result;\n}\nconsole.log(deepClone(data));\n</pre></br><p>If you also want to handle <strong>arrays</strong>, <strong>dates</strong>, <strong>maps</strong>, and <strong>sets</strong>, you can extend it ‚Äî but for normal JSON-style data (objects, arrays, strings, numbers, booleans, null), this version is 100% correct and efficient.</p>",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 202,
                "text": "<p>Can you <strong>implement</strong> a <strong>deep copy</strong> manually?</p>"
            },
            {
                "description": "<pre data-language=\"plain\">\nfunction curry(fn) {\n  return function curried(...args) {\n    // If enough arguments have been provided, call the original function\n    if (args.length &gt;= fn.length) {\n      return fn(...args);\n    }\n    // Otherwise, return a function that collects more arguments\n    return function (...nextArgs) {\n      return curried(...args, ...nextArgs);\n    };\n  };\n}\n\nfunction add(a, b, c) {\n  return a + b + c;\n}\n\nconst curriedAdd = curry(add);\n\nconsole.log(curriedAdd(1)(2)(3)); // 6\nconsole.log(curriedAdd(1, 2)(3)); // 6\nconsole.log(curriedAdd(1)(2, 3)); // 6\n</pre></br>",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 203,
                "text": "<p>Can you implement a <strong>curry function</strong></p><p>// curry(add)(1)(2)(3) should equal add(1, 2, 3)</p></br><p>function curry(fn) {</p><p>}</p></br><p>function add(a, b, c) {</p><p>return a + b + c;</p><p>}</p></br><p>const curriedAdd = curry(add);</p><p>console.log(curriedAdd(1)(2)(3)); // 6</p>"
            },
            {
                "description": "<pre data-language=\"plain\">\nfunction isBalanced(brackets) {\n  const stack = [];\n  const pairs = {\n    &#39;)&#39;: &#39;(&#39;,\n    &#39;}&#39;: &#39;{&#39;,\n    &#39;]&#39;: &#39;[&#39;\n  };\n\n  for (let char of brackets) {\n    if ([&#39;(&#39;, &#39;{&#39;, &#39;[&#39;].includes(char)) {\n      stack.push(char);\n    } else if ([&#39;)&#39;, &#39;}&#39;, &#39;]&#39;].includes(char)) {\n      if (stack.length === 0 || stack[stack.length - 1] !== pairs[char]) {\n        return false;\n      }\n      stack.pop();\n    }\n  }\n\n  return stack.length === 0;\n}\n\n// ‚úÖ Test cases\nconsole.log(isBalanced([&#39;[&#39;, &#39;{&#39;, &#39;(&#39;, &#39;)&#39;, &#39;}&#39;, &#39;]&#39;])); // true\nconsole.log(isBalanced([&#39;[&#39;, &#39;(&#39;, &#39;]&#39;, &#39;)&#39;]));           // false\nconsole.log(isBalanced([&#39;{&#39;, &#39;[&#39;, &#39;]&#39;, &#39;}&#39;]));           // true\nconsole.log(isBalanced([&#39;(&#39;, &#39;)&#39;, &#39;[&#39;, &#39;}&#39;, &#39;]&#39;]));      // false\n</pre>",
                "subjectId": 7,
                "sectionId": 66,
                "subSectionId": -1,
                "contentId": 204,
                "text": "<p>Check Brackets are balance or not?</p><p>a = [&#39;[&#39;, &#39;{&#39;, &#39;(&#39;, &#39;)&#39;, &#39;}&#39;, &#39;]&#39;];</p>"
            },
            {
                "text": "<p>Find Prime Number list and remove duplicate number.</p>",
                "sectionId": 66,
                "subSectionId": -1,
                "subjectId": 7,
                "contentId": 400,
                "description": "<pre data-language=\"plain\">\nconst arr = [2, 3, 5, 16, 23, 49, 47, 63, 93, 92, 91, 23, 47, 91, 101, 102];\n\nfunction isPrime(n) {\n    if(n &lt;= 1) return false;\n    if(n === 2) return true;\n    if(n % 2 === 0) return false;\n    \n    for(let i=3; i&lt;n/2; i+=2) {\n        if(n%i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n// Method1\nconst primeNumberList = [...new Set(arr.filter(isPrime))];\nconsole.log(primeNumberList);\n\n// Method2\nconst primeNumberList = arr.filter((d, index) =&gt; arr.indexOf(d) === index &amp;&amp; isPrime(d));\nconsole.log(primeNumberList);\n</pre>"
            }
        ]
    }
]