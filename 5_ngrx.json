[
    {
        "name": "<p><strong>NgRx and NgRx Workflow, key concept (Store, Actions, Reducer, Selectors, effects)</strong></p>",
        "subjectId": 5,
        "sectionId": 48,
        "subSectionId": -1,
        "subSections": [
            {
                "name": "<p><strong>NgRx Flow</strong></p>",
                "subjectId": 5,
                "sectionId": 48,
                "subSectionId": 49,
                "subSections": [],
                "contents": [
                    {
                        "description": "<p>NgRx follows the <strong>Redux pattern</strong> with a <strong>unidirectional data flow</strong>.</p><p>The <strong>component </strong>first <strong>dispatches </strong>an action <strong>describing what happened</strong>.</p><p>If the <strong>action </strong>requires an <strong>API call </strong>or <strong>async work</strong>, an <strong>effect </strong>handles it and <strong>dispatches </strong>a <strong>success </strong>or <strong>failure </strong>action.</p><p> <strong>Reducers </strong>listen to these <strong>actions</strong> and update the <strong>store </strong>using <strong>immutable </strong>updates.</p><p> <strong>Components </strong>then use <strong>selectors </strong>to subscribe to specific slices of state.</p><p> This cycle ensures predictable <strong>state management</strong>, <strong>easy debugging</strong>, and <strong>clean separation of concerns</strong>.</p>",
                        "subjectId": 5,
                        "sectionId": 48,
                        "subSectionId": 49,
                        "contentId": 136,
                        "text": "<p>Can you explain NgRx Flow (Redux Pattern in Angular)?</p>"
                    }
                ]
            },
            {
                "name": "<p><strong>key concept of NgRx (Store, Actions, Reducer, Selectors, effects)</strong></p>",
                "subjectId": 5,
                "sectionId": 48,
                "subSectionId": 50,
                "subSections": [],
                "contents": [
                    {
                        "description": "<p>The <strong>Store </strong>in <strong>NgRx </strong>is a <strong>centralized state </strong>container for the whole <strong>Angular application</strong>. It acts as a <strong>single source of truth</strong>.</p></br><p><strong>Components </strong>don’t store data themselves — instead, they <strong>dispatch actions</strong>, and <strong>reducers update</strong> the Store immutably.</p></br><p>We then access the <strong>state </strong>using <strong>selectors</strong>, which are observable streams.</p><p>This makes the <strong>application predictable</strong>, <strong>easy to debug</strong>, and <strong>scalable</strong>.</p>",
                        "subjectId": 5,
                        "sectionId": 48,
                        "subSectionId": 50,
                        "contentId": 139,
                        "text": "<p>What is ‘store’ in NgRx?</p>"
                    },
                    {
                        "description": "<p><strong>Actions </strong>in <strong>NgRx </strong>are <strong>plain objects</strong> that represent events happening in the application.</p><p>They always have a type and may optionally carry a <strong>payload</strong>.</p></br><p><strong>Components </strong>dispatch <strong>actions</strong>, and <strong>reducers/effects</strong> listen to them.</p></br><p><strong>Actions </strong>do not contain any <strong>business logic</strong>—they simply describe<strong> <em>what happened</em></strong>.</p></br><p>This makes the application’s event flow <strong>predictable </strong>and<strong> easy to debug</strong>.</p></br><pre data-language=\"plain\">\nexport const loadUsers = createAction(&#39;[User] Load Users&#39;);\n\nexport const loadUsersSuccess = createAction(\n  &#39;[User] Load Users Success&#39;,\n  props&lt;{ users: User[] }&gt;()\n);\n</pre></br>",
                        "subjectId": 5,
                        "sectionId": 48,
                        "subSectionId": 50,
                        "contentId": 140,
                        "text": "<p>What is ‘Actions’ in NgRx?</p>"
                    },
                    {
                        "description": "<p>A <strong>Reducer </strong>in <strong>NgRx </strong>is a<strong> pure function</strong> that takes the <strong>current state</strong> and an <strong>action</strong>, and returns a new <strong>immutable state</strong>.</p></br><p><strong>Reducers </strong>contain<strong> no business logic</strong> or<strong> side effects</strong> — they only describe how the state changes in response to events.</p></br><p>When a <strong>component </strong>or <strong>effect</strong> dispatches an <strong>action</strong>, the <strong>reducer </strong>listens for that <strong>action </strong>and updates the <strong>store </strong>accordingly.</p></br><p>This ensures predictable <strong>state transitions</strong> and makes the application much easier to <strong>debug and test</strong>.</p></br><pre data-language=\"plain\">\nexport const employeeReducer = createReducer(\n  initialState,\n  on(updateEmployee, (state, { employee }) =&gt; ({\n    ...state,\n    employees: state.employees.map(e =&gt;\n      e.id === employee.id ? { ...e, ...employee } : e\n    )\n  }))\n);\n</pre></br>",
                        "subjectId": 5,
                        "sectionId": 48,
                        "subSectionId": 50,
                        "contentId": 141,
                        "text": "<p>What is ‘Reducer’ in NgRx?</p>"
                    },
                    {
                        "description": "<p><strong>Selectors </strong>in <strong>NgRx </strong>are <strong>pure functions</strong> that extract specific <strong>pieces of state</strong> from the <strong>Store</strong>.</p></br><p>They help <strong>components </strong>read data in a clean and optimized way.</p></br><p><strong>Selectors </strong>can also derive or compute values, and they use memoization so the same computation is not repeated unnecessarily.</p></br><p>This keeps <strong>components lightweight </strong>and improves <strong>performance</strong>.</p></br><pre data-language=\"plain\">\nexport const selectUserState = createFeatureSelector&lt;UserState&gt;(&#39;users&#39;);\n</pre></br><pre data-language=\"plain\">\nexport const selectUserList = createSelector(\n  selectUserState,\n  (state) =&gt; state.users\n);\n\nexport const selectUserLoading = createSelector(\n  selectUserState,\n  (state) =&gt; state.loading\n);\n</pre>",
                        "subjectId": 5,
                        "sectionId": 48,
                        "subSectionId": 50,
                        "contentId": 142,
                        "text": "<p>What is ‘Selectors’ in NgRx?</p>"
                    },
                    {
                        "description": "<p><strong>Effects </strong>in <strong>NgRx </strong>handle <strong>side effects</strong> such as <strong>API calls</strong>.</p><p><strong>Reducers </strong>must <strong>stay pure</strong>, so any <strong>asynchronous </strong>logic is moved into <strong>Effects</strong>.</p><p><strong>Effects </strong>listen to <strong>actions</strong>, perform the <strong>async task</strong>, and return <strong>new actions</strong> such as <strong>success </strong>or <strong>failure</strong>.</p><p>This keeps <strong>components</strong> clean and keeps the data flow <strong>unidirectional </strong>and <strong>predictable</strong>.</p></br><pre data-language=\"plain\">\nloadUsers$ = createEffect(() =&gt;\n  this.actions$.pipe(\n    ofType(loadUsers),\n    mergeMap(() =&gt;\n      this.userService.getUsers().pipe(\n        map(users =&gt; loadUsersSuccess({ users })),\n        catchError(() =&gt; of(loadUsersFailure()))\n      )\n    )\n  )\n);\n</pre></br>",
                        "subjectId": 5,
                        "sectionId": 48,
                        "subSectionId": 50,
                        "contentId": 143,
                        "text": "<p>What are ‘effects’ in NgRx?</p>"
                    }
                ]
            }
        ],
        "contents": [
            {
                "description": "<p><strong>NgRx </strong>is a <strong>state management library</strong> for <strong>Angular </strong>based on the <strong>Redux pattern</strong>. It helps maintain <strong>application state</strong> in a <strong>predictable </strong>and <strong>centralized </strong>way using a <strong>unidirectional data flow</strong>. <strong>NgRx </strong>provides a <strong>global store</strong> for <strong>managing state</strong>, <strong>actions </strong>to trigger changes, <strong>reducers </strong>to update the state immutably, <strong>selectors</strong> for reading state, and <strong>effects </strong>for handling <strong>async operations</strong> like <strong>API calls</strong>. It is especially useful in large apps where <strong>multiple components</strong> share data, making the application more <strong>scalable</strong>, <strong>testable</strong>, and <strong>easier to debug</strong>.</p></br><p><strong>Note:</strong></p><p><strong>Unidirectional Data Flow: </strong></p><p>Unidirectional data flow means <strong>data moves in one single direction</strong> through the application, following a fixed, predictable path.</p><p>It <strong>never flows backward or in multiple directions</strong>.</p>",
                "subjectId": 5,
                "sectionId": 48,
                "subSectionId": -1,
                "contentId": 137,
                "text": "<p>What is NgRx in Angular?</p>"
            }
        ]
    },
    {
        "name": "<p><strong>createSelector and createFeatureSelector, Mutable and Immutable </strong></p>",
        "sectionId": 116,
        "subSectionId": -1,
        "subjectId": 5,
        "contents": [],
        "subSections": [
            {
                "name": "<p><strong>createSelector and createFeatureSelector</strong></p>",
                "sectionId": 116,
                "subSectionId": 117,
                "subjectId": 5,
                "contents": [
                    {
                        "text": "<p>Difference between <code>createSelector</code> and <code>createFeatureSelector</code> in NgRx</p>",
                        "sectionId": 116,
                        "subSectionId": 117,
                        "subjectId": 5,
                        "contentId": 405,
                        "description": "<p><strong>createFeatureSelector </strong>is used to fetch the entire <strong>feature state</strong> using the <strong>feature key</strong>. It’s typically the first <strong>selector </strong>we create after registering a <strong>reducer</strong>.</p></br><p><strong>createSelector </strong>is used to derive more granular or computed data from the <strong>feature state</strong>, and it can combine multiple <strong>selectors</strong>.</p></br><p>In short, <strong>createFeatureSelector </strong>gets the main feature slice, and <strong>createSelector </strong>lets us drill deeper or compute values from that slice.</p></br><pre data-language=\"plain\">\nexport const selectEmployeeFeature =\n  createFeatureSelector&lt;EmployeeState&gt;(&#39;employees&#39;);\n</pre></br><pre data-language=\"plain\">\nexport const selectEmployees = createSelector(\n  selectEmployeeFeature,\n  (state) =&gt; state.employees\n);\n</pre>"
                    }
                ],
                "subSections": []
            },
            {
                "name": "<p><strong>Mutable and Immutable </strong></p>",
                "sectionId": 116,
                "subSectionId": 124,
                "subjectId": 5,
                "contents": [
                    {
                        "text": "<p>What is difference between <strong>Mutable </strong>and <strong>Immutable</strong>?</p>",
                        "sectionId": 116,
                        "subSectionId": 124,
                        "subjectId": 5,
                        "contentId": 416,
                        "description": "<p><strong>Mutable </strong>values can be changed directly in <strong>memory</strong>, while <strong>immutable</strong> values always create a <strong>new copy</strong> when changed. In <strong>JavaScript</strong>, <strong>objects</strong> and <strong>arrays </strong>are <strong>mutable</strong>; <strong>primitives </strong>like <strong>numbers</strong>, <strong>strings</strong>, and <strong>booleans </strong>are <strong>immutable</strong>.</p></br><p><strong>Mutable Example: Arrays</strong></p><pre data-language=\"plain\">\nconst arr = [1, 2, 3];\nconst arr2 = arr;\n\narr2.push(4);\n\nconsole.log(arr); // [1, 2, 3, 4]\nconsole.log(arr2); // [1, 2, 3, 4]\n</pre></br><p><strong>Immutable Example: Numbers</strong></p><pre data-language=\"plain\">\nlet x = 10;\nlet y = x;\n\ny = y + 5;\n\nconsole.log(x); // 10\nconsole.log(y); // 15\n</pre></br>"
                    },
                    {
                        "text": "<p>how to make <strong>objects </strong>and <strong>arrays immutable?</strong></p>",
                        "sectionId": 116,
                        "subSectionId": 124,
                        "subjectId": 5,
                        "contentId": 417,
                        "description": "<p><strong> Why Make Objects &amp; Arrays Immutable?</strong></p><ul><li>Prevent accidental modifications</li><li>Keep application state predictable</li><li>Essential for NgRx, Redux, and functional programming</li><li>Makes debugging and testing easier</li></ul></br><p><strong>1. Using </strong><code><strong>Object.freeze()</strong></code><strong> (Shallow Immutability)</strong></p><pre data-language=\"plain\">\nconst user = Object.freeze({\n  name: &quot;Vivek&quot;,\n  age: 31\n});\n\nuser.name = &quot;Rahul&quot;;  // ❌ fails silently in non-strict mode\nconsole.log(user.name); // Vivek\n\n\n// Nested objects remain mutable. (Limitation: It is shallow)\nconst emp = Object.freeze({\n  details: {\n    city: &quot;Mumbai&quot;\n  }\n});\n\nemp.details.city = &quot;Delhi&quot;; // ❌ still changes!\n</pre></br><p><strong>2. Deep Freeze (Full Immutability)</strong></p><pre data-language=\"plain\">\nfunction deepFreeze(obj) {\n  Object.keys(obj).forEach(key =&gt; {\n    if (typeof obj[key] === &#39;object&#39; &amp;&amp; obj[key] !== null) {\n      deepFreeze(obj[key]);\n    }\n  });\n  return Object.freeze(obj);\n}\n\nconst user = deepFreeze({\n  name: &quot;Vivek&quot;,\n  address: { city: &quot;Mumbai&quot;, pin: 400001 }\n});\n\nuser.address.city = &quot;Delhi&quot;;  // ❌ Not allowed\nconsole.log(user.address.city); // &quot;Mumbai&quot;\n</pre></br><p><strong>3. Using Spread Operator to Create New Copies (Most Common)</strong></p><p><strong>Immutable Object Update</strong></p><pre data-language=\"plain\">\nconst user = { name: &quot;Vivek&quot;, age: 31 };\n\nconst updatedUser = {\n  ...user,\n  age: 32\n};\n\nconsole.log(updatedUser); // new object\nconsole.log(user);        // unchanged\n</pre></br><p><strong>Immutable Array Update</strong></p><pre data-language=\"plain\">\nconst arr = [1, 2, 3];\n\nconst updatedArr = [...arr, 4];\n\nconsole.log(updatedArr); // [1, 2, 3, 4]\nconsole.log(arr);        // [1, 2, 3]\n</pre></br><p><strong>Replace element immutably</strong></p><pre data-language=\"plain\">\nconst arr = [10, 20, 30];\n\nconst newArr = arr.map(val =&gt; val === 20 ? 200 : val);\n\nconsole.log(newArr); // [10, 200, 30]\n</pre></br><p><strong>Remove element immutably</strong></p><pre data-language=\"plain\">\nconst arr = [1, 2, 3];\n\nconst newArr = arr.filter(v =&gt; v !== 2);\n\nconsole.log(newArr); // [1, 3]\n</pre></br><p><strong>Using structuredClone() (Deep Copy)</strong></p><pre data-language=\"plain\">\nconst user = {\n  name: &quot;Vivek&quot;,\n  address: { city: &quot;Mumbai&quot; }\n};\n\nconst newUser = structuredClone(user);\nnewUser.address.city = &quot;Delhi&quot;;\n\nconsole.log(user.address.city);   // Mumbai\nconsole.log(newUser.address.city); // Delhi\n</pre></br>"
                    },
                    {
                        "description": "<p><strong>NgRx </strong>recommends:</p><ol><li>We should never change an existing <strong>state object </strong>or <strong>array </strong>directly. Instead, always return a <strong><em>new</em> object</strong> or <strong>array </strong>with the <strong>updated values</strong>.</li></ol><ul><li>Use <strong>spread operator</strong> to return <strong>new objects.</strong></li><li>Use <strong>arrays </strong>with <code><strong>.map()</strong></code><strong>, </strong><code><strong>.filter()</strong></code><strong>, </strong><code><strong>.concat()</strong></code><strong> </strong>that returns <strong>new array. </strong></li></ul></br><p>export const employeeReducer = createReducer(</p><p>  initialState,</p><p>  on(updateEmployee, (state, { employee }) =&gt; ({</p><p>    ...state,</p><p>    employees: state.employees.map(e =&gt;</p><p>      e.id === employee.id ? { ...e, ...employee } : e</p><p>    )</p><p>  }))</p><p>);</p></br><p><strong>NgRx </strong>achieves immutability by never changing the <strong>old state</strong>. Instead, it always creates a new one using simple <strong>JavaScript tools</strong> like the <strong>spread operator </strong>for copying, <strong>map()</strong> for updating array items, and <strong>filter()</strong> for removing items. This keeps state <strong>predictable</strong>, helps <strong>Angular detect changes</strong> quickly, and allows <strong>DevTools</strong> to track <strong>history</strong>.</p></br>",
                        "subjectId": 5,
                        "sectionId": 116,
                        "subSectionId": 124,
                        "contentId": 138,
                        "text": "<p>How does NgRx handle immutability?</p>"
                    }
                ],
                "subSections": []
            }
        ]
    }
]