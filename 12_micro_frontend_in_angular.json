[
    {
        "name": "<p><strong>Core Concepts</strong></p>",
        "sectionId": 104,
        "subSectionId": -1,
        "subjectId": 12,
        "contents": [
            {
                "text": "<p>What are Micro Frontends, and why do we need them?</p>",
                "sectionId": 104,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 367,
                "description": "<p><a href=\"https://chatgpt.com/c/68d6a5a3-0d6c-8330-9a6c-f1b654eeddf2\" rel=\"noopener noreferrer\" target=\"_blank\">https://chatgpt.com/c/68d6a5a3-0d6c-8330-9a6c-f1b654eeddf2</a></p><p><a href=\"https://chatgpt.com/c/692e59d9-6e74-8321-956f-7a10ea0cfe9b\" rel=\"noopener noreferrer\" target=\"_blank\">https://chatgpt.com/c/692e59d9-6e74-8321-956f-7a10ea0cfe9b</a></p></br><p>Micro Frontends are an architectural approach where a large frontend app is split into smaller, independent modules owned by different teams. The main advantages are <strong>independent development and deployment</strong>, <strong>scalability of teams and code</strong>, <strong>technology flexibility</strong>, <strong>easier maintenance</strong>, <strong>incremental upgrades</strong>, and <strong>failure isolation</strong>, meaning one part failing won’t break the whole app.</p></br><p>On the downside, they introduce <strong>complexity in integration and routing</strong>, <strong>setup overhead</strong>, potential <strong>performance issues</strong> if not optimized, <strong>consistency challenges</strong> in UI/UX across teams, and <strong>more complex end-to-end testing</strong>.</p><p>Overall, they are ideal for large applications with multiple teams, but not always necessary for smaller projects.</p></br><p>A <strong>Monolithic Angular app</strong> is a <strong>single, large frontend application</strong> built as one unified codebase, where all features, modules, and components reside together. It’s the traditional way of building Angular applications.</p>"
            },
            {
                "text": "<p>What is the difference between Host and Remote apps?</p>",
                "sectionId": 104,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 368,
                "description": "<p>The <strong>Host</strong> is the <strong>main application</strong> that loads or consumes features from other micro frontends (remotes). It acts as the <strong>entry point</strong> of the entire system.</p></br><p>The <strong>Remote</strong> is an independent MFE (Micro Frontend) that exposes its components or modules so the host can load them. It runs independently on its own port.</p>"
            },
            {
                "text": "<p>What is remoteEntry.js and why is it important?</p>",
                "sectionId": 104,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 369,
                "description": "<p><code>remoteEntry.js</code> is a <strong>JavaScript file generated by Webpack Module Federation</strong> in a Micro Frontend setup.</p><p> It acts as the <strong>“gateway file”</strong> that exposes modules, components, or features from a <strong>Remote App</strong> so that a <strong>Host App</strong> can load them at runtime.</p>"
            },
            {
                "text": "<p>What is the significance of shared libraries in Module Federation?</p>",
                "sectionId": 104,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 370,
                "description": "<p>Shared libraries ensure that host and remote apps use the same dependency instance (like Angular/RxJS), preventing duplicates, reducing bundle size, avoiding version conflicts, and improving runtime performance.</p></br><pre data-language=\"plain\">\n// Host\nshared: {\n  &quot;@angular/core&quot;: { singleton: true, strictVersion: true },\n  &quot;@angular/common&quot;: { singleton: true, strictVersion: true },\n  &quot;rxjs&quot;: { singleton: true }\n}\n</pre></br><pre data-language=\"plain\">\n// Remote\nshared: {\n  &quot;@angular/core&quot;: { singleton: true, strictVersion: true },\n  &quot;@angular/common&quot;: { singleton: true, strictVersion: true },\n  &quot;rxjs&quot;: { singleton: true }\n}\n</pre>"
            },
            {
                "text": "<p>What is Webpack 5 Module Federation, and how does Angular support it?</p>",
                "sectionId": 104,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 371,
                "description": "<p><strong>Module Federation</strong> (introduced in Webpack 5) is a feature that allows <strong>multiple separate applications</strong> to:</p><ul><li>Share code <strong>at runtime</strong></li><li>Load modules <strong>dynamically from another app</strong></li><li>Work independently but still integrate seamlessly</li><li>Avoid rebuilding the whole system when one app changes</li></ul></br><p><strong>Module Federation </strong>enables Micro Frontend architecture.</p></br><p>Angular supports Module Federation through: <code>@angular-architects/module-federation</code>  (Angular plugin)</p></br><p>We can use Angular CLI command for host</p><p><code>ng add @angular-architects/module-federation@15.0.0 --project host-app --port 4200 --type host</code></p></br><p>We can use Angular CLI command for remote</p><p><code>ng add @angular-architects/module-federation@15.0.0 --project remote-app --port 4201 --type remote</code></p></br><p>It generate <code>webpack.config.js</code>  </p>"
            },
            {
                "text": "<p> What problems occur when Angular versions differ across MFEs?</p>",
                "sectionId": 104,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 389,
                "description": "<p>When Host and Remote apps use <strong>different Angular versions</strong>, Module Federation may still try to share Angular as a <strong>singleton</strong>, which leads to several runtime issues.</p></br><p>1. Multiple Angular Instances (Breaks Change Detection).</p><p>2. DI (Dependency Injection) Conflicts like Each MFE may create its own DI container and Services may become duplicated.</p><p>3. RxJS Version Mismatch. If Angular versions differ, the required RxJS version may differ too.</p>"
            }
        ],
        "subSections": []
    },
    {
        "name": "<p><strong>Integration &amp; Communication, Routing, ViewContainerRef</strong></p>",
        "sectionId": 106,
        "subSectionId": -1,
        "subjectId": 12,
        "contents": [
            {
                "text": "<p>How do you configure Angular with Module Federation (host and remote apps)?</p>",
                "sectionId": 106,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 377,
                "description": "<p>First, <strong>create a workspace</strong> for the applications using:</p></br><pre data-language=\"plain\">\nng new mono-repo-workspace --create-application=false\n</pre></br><p>Then <strong>change directory</strong> to the workspace:</p></br><pre data-language=\"plain\">\ncd mono-repo-workspace\n</pre></br><p>In the second step, <strong>generate the host (shell) application</strong> using:</p></br><pre data-language=\"plain\">\nng generate application shell --routing --style=scss\n</pre></br><p>And <strong>generate the remote application</strong> using:</p></br><pre data-language=\"plain\">\nng generate application dashboard --routing --style=scss\n</pre></br><p>In the third step, <strong>add the Module Federation plugin</strong> by installing the <strong>official community package</strong>:</p></br><pre data-language=\"plain\">\nnpm install @angular-architects/module-federation --save-dev\n</pre></br><p>Then <strong>add it to each app</strong>:</p></br><p>For the <strong>host</strong>:</p></br><pre data-language=\"plain\">\nng add @angular-architects/module-federation --project shell --type host\n</pre></br><p>For the <strong>remote</strong>:</p></br><pre data-language=\"plain\">\nng add @angular-architects/module-federation --project dashboard --type remote\n</pre></br><p>This will generate <code><strong>webpack.config.js</strong></code> and <code><strong>webpack.prod.config.js</strong></code> in both apps.</p>"
            },
            {
                "text": "<p>How do you configure module-federation.config.js in Angular?</p>",
                "sectionId": 106,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 378,
                "description": "<p><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">Angular supports Module Federation through: </span><code style=\"background-color: rgb(236, 236, 236); color: rgb(0, 0, 0);\">@angular-architects/module-federation</code><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\"> (Angular plugin).</span></p></br><p>We can use Angular CLI command for host</p><p><code>ng add @angular-architects/module-federation@15.0.0 --project host-app --port 4200 --type host</code></p></br><p>We can use Angular CLI command for remote</p><p><code>ng add @angular-architects/module-federation@15.0.0 --project remote-app --port 4201 --type remote</code></p></br><p>It generates <code>webpack.config.js</code></p></br><p><code>webpack.config.js</code> for remote:</p><p><code>webpack.config.js</code> contains <code>name</code> , <code>exposes</code> , <code>shared</code></p></br><p>name: Unique name of the remote app</p><p>exposes: exposes are used to expose modules/components that the Host will load.</p><p>shared: shared are used to make libraries that must be singletons (Angular, RxJS, etc.)</p></br><p><code>webpack.config.js</code> for host:</p><p><code>webpack.config.js</code> contains <code>remotes</code> , <code>shared</code></p><p>remotes is used to make MFEs the Host will load at runtime.</p></br>"
            },
            {
                "text": "<p>How do you manage CSS/style isolation in Angular Micro Frontends?</p>",
                "sectionId": 106,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 379,
                "description": "<p>When multiple Micro Frontends (MFEs) run together, their styles can <strong>leak</strong> into each other (global CSS conflicts).</p></br><p>To prevent this, Angular provides several mechanisms for <strong>style isolation</strong>.</p></br><p>We can use encapsulation: <code style=\"background-color: rgb(236, 236, 236); color: rgb(0, 0, 0);\">encapsulation: ViewEncapsulation.Emulated</code> , <code style=\"color: rgb(0, 0, 0); background-color: rgb(236, 236, 236);\">encapsulation: ViewEncapsulation.ShadowDom</code> or we can wrap each remote app by <strong>unique wrapper class</strong>.</p></br><pre data-language=\"plain\">\n@Component({\n  selector: &#39;app-user&#39;,\n  templateUrl: &#39;./user.component.html&#39;,\n  styleUrls: [&#39;./user.component.scss&#39;],\n  encapsulation: ViewEncapsulation.Emulated\n})\n</pre></br>"
            },
            {
                "text": "<p>What are the common communication methods between MFEs?</p>",
                "sectionId": 106,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 380,
                "description": "<p><strong>Micro Frontends</strong> can communicate using <strong>Custom Events</strong>, <strong>Shared Global State (like RxJS or NgRx)</strong>, <strong>Shared Libraries</strong>, <strong>Browser Storage</strong>, <strong>URL parameters</strong>, <strong>postMessage </strong>for<strong> cross-domain apps</strong>, <strong>Event Bus</strong>, or <strong>backend APIs</strong>.</p><p>The method depends on how <strong>tightly coupled</strong> they are allowed to be. <strong>Custom Events</strong> and <strong>postMessage </strong>are great for <strong>loose coupling</strong>, while <strong>shared libraries</strong> and <strong>global state</strong> are used for <strong>structured</strong>, <strong>real-time communication</strong>.</p></br><p>1. CustomEvents</p><p>2. window.postMessage</p><p>3. Shared RxJS store</p><p>4. Shared libraries/services</p><p>5. BroadcastChannel API</p><p>6. LocalStorage/sessionStorage</p></br><p><strong>CustomEvents: </strong></p><pre data-language=\"plain\">\n// Dispatch Event\nconst event = new CustomEvent(&#39;header&#39;, {\n      detail: {\n        name: &#39;Todo List&#39;,\n      }\n    });\n    dispatchEvent(event);\n</pre></br><pre data-language=\"true\">\n// Receive Event\nheaderListener: any;\n\nthis.headerListener = (e: any) =&gt; {\n      this.headerName = e?.detail?.name;\n    }\n    window.addEventListener(&#39;header&#39;, this.headerListener);\n\n// Destroy Event\nwindow.removeEventListener(&#39;header&#39;, this.headerListener);\n</pre></br><pre data-language=\"plain\">\n// Receive Event using fromEvent RxJS\ndestroy$ = new Subject&lt;void&gt;();\n\nfromEvent(window, &#39;header&#39;).pipe(takeUntil(this.destroy$)).subscribe((d: any) =&gt; {\n      this.headerName = e?.detail?.name;\n    });\n\n// Destroy Observable\nthis.destroy$.next();\nthis.destroy$.complete();\n</pre></br><p><strong>postMessage:</strong></p><pre data-language=\"plain\">\nwindow.postMessage({ type: &#39;SELECT_TODO&#39;, id: 5 }, &#39;*&#39;);\nwindow.addEventListener(&#39;message&#39;, (event) =&gt; {\n   console.log(event.data);\n});\n\nwindow.addEventListener(&#39;message&#39;, (event) =&gt; {\n  // FILTER 1: Validate origin if known\n  if (event.origin !== &#39;https://my-trusted-url.com&#39;) return;\n\n  // FILTER 2: Validate your message format\n  if (!event.data || !event.data.type) return;\n\n  console.log(&#39;My App Message:&#39;, event.data);\n});\n\n</pre></br><p>GithutLink:</p></br><p><strong style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\">1. mfe1-app -&gt; host-app -&gt; mfe2-app through @Input and @Output: </strong></p><p><a href=\"https://github.com/777Vikki/microfrontend-mono-repo-angular15/tree/mfe1-host-mfe2-communication-input-output/projects\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/777Vikki/microfrontend-mono-repo-angular15/tree/mfe1-host-mfe2-communication-input-output/projects</a></p></br><p><strong>2. Shared-lib:</strong></p><p><a href=\"https://github.com/777Vikki/microfrontend-mono-repo-angular15/tree/communication-shared-lib-subject/projects\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/777Vikki/microfrontend-mono-repo-angular15/tree/communication-shared-lib-subject/projects</a></p><p><span style=\"background-color: rgba(129, 139, 152, 0.15); color: rgb(31, 35, 40);\">README.md:</span></p><p><a href=\"https://github.com/777Vikki/microfrontend-mono-repo-angular15/blob/communication-shared-lib-subject/README.md\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/777Vikki/microfrontend-mono-repo-angular15/blob/communication-shared-lib-subject/README.md</a></p></br><p><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">3. Event Bus:</strong></p><p>README.md: <a href=\"https://github.com/777Vikki/microfrontend-mono-repo-angular15/tree/communication-event-bus\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/777Vikki/microfrontend-mono-repo-angular15/tree/communication-event-bus</a></p><p>event-bus.ts: <a href=\"https://github.com/777Vikki/microfrontend-mono-repo-angular15/blob/communication-event-bus/projects/shared-lib/src/lib/event-bus.ts\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/777Vikki/microfrontend-mono-repo-angular15/blob/communication-event-bus/projects/shared-lib/src/lib/event-bus.ts</a></p><p>public-api.ts: <a href=\"https://github.com/777Vikki/microfrontend-mono-repo-angular15/blob/communication-event-bus/projects/shared-lib/src/public-api.ts\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/777Vikki/microfrontend-mono-repo-angular15/blob/communication-event-bus/projects/shared-lib/src/public-api.ts</a></p><p>host-app(subscribe): <a href=\"https://github.com/777Vikki/microfrontend-mono-repo-angular15/blob/communication-event-bus/projects/host-app/src/app/app.component.ts\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/777Vikki/microfrontend-mono-repo-angular15/blob/communication-event-bus/projects/host-app/src/app/app.component.ts</a></p><p>mfe1-app(trigger): <a href=\"https://github.com/777Vikki/microfrontend-mono-repo-angular15/blob/communication-event-bus/projects/mfe1-app/src/app/todo-list/todo-list.component.ts\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/777Vikki/microfrontend-mono-repo-angular15/blob/communication-event-bus/projects/mfe1-app/src/app/todo-list/todo-list.component.ts</a></p>"
            },
            {
                "text": "<p>Difference between CustomEvent and postMessage?</p>",
                "sectionId": 106,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 391,
                "description": "<p><strong>CustomEvent </strong>is for <strong>communication </strong>inside the same <strong>DOM</strong>; <strong>postMessage </strong>is for <strong>communication </strong>between different <strong>windows</strong>, <strong>tabs</strong>, or <strong>iframes</strong>—including <strong>cross-origin</strong>.</p>"
            },
            {
                "text": "<p>How do you share authentication state across MFEs?</p>",
                "sectionId": 106,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 393,
                "description": ""
            }
        ],
        "subSections": [
            {
                "name": "<p><strong>Routing</strong></p>",
                "sectionId": 106,
                "subSectionId": 109,
                "subjectId": 12,
                "contents": [
                    {
                        "text": "<p>How do you implement routing in Microfrontends?</p>",
                        "sectionId": 106,
                        "subSectionId": 109,
                        "subjectId": 12,
                        "contentId": 394,
                        "description": ""
                    },
                    {
                        "text": "<p>How do you lazy load a remote Angular component/module?</p>",
                        "sectionId": 106,
                        "subSectionId": 109,
                        "subjectId": 12,
                        "contentId": 395,
                        "description": ""
                    }
                ],
                "subSections": []
            },
            {
                "name": "<p><strong>ViewContainerRef</strong></p>",
                "sectionId": 106,
                "subSectionId": 110,
                "subjectId": 12,
                "contents": [
                    {
                        "text": "<p>How do you dynamically create a remote component using ViewContainerRef?</p>",
                        "sectionId": 106,
                        "subSectionId": 110,
                        "subjectId": 12,
                        "contentId": 396,
                        "description": ""
                    }
                ],
                "subSections": []
            }
        ]
    },
    {
        "name": "<p><strong>Performance &amp; Deployment</strong></p>",
        "sectionId": 107,
        "subSectionId": -1,
        "subjectId": 12,
        "contents": [
            {
                "text": "<p>What are the performance challenges in Micro Frontends, and how do you optimize them?</p>",
                "sectionId": 107,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 381,
                "description": ""
            },
            {
                "text": "<p>What happens if a remote MFE is offline or remoteEntry fails to load?</p>",
                "sectionId": 107,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 382,
                "description": ""
            },
            {
                "text": "<p>How do you handle environment-specific remote URLs?</p>",
                "sectionId": 107,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 383,
                "description": ""
            },
            {
                "text": "<p>How do you secure Microfrontends?</p>",
                "sectionId": 107,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 384,
                "description": ""
            }
        ],
        "subSections": []
    },
    {
        "name": "<p><strong>Scenario / Advanced</strong></p>",
        "sectionId": 108,
        "subSectionId": -1,
        "subjectId": 12,
        "contents": [
            {
                "text": "<p>If two Micro Frontends use different Angular versions, how do you make them work together?</p>",
                "sectionId": 108,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 385,
                "description": ""
            },
            {
                "text": "<p>How would you migrate an existing monolithic Angular app into Micro Frontends?</p>",
                "sectionId": 108,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 386,
                "description": ""
            },
            {
                "text": "<p>How would you rollback a specific Micro Frontend if a deployment fails?</p>",
                "sectionId": 108,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 387,
                "description": ""
            },
            {
                "text": "<p>What are some real-world challenges you faced (or might face) in Micro Frontend implementation?</p>",
                "sectionId": 108,
                "subSectionId": -1,
                "subjectId": 12,
                "contentId": 388,
                "description": ""
            }
        ],
        "subSections": []
    }
]