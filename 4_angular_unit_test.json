[
    {
        "name": "<p><strong>Basic</strong></p>",
        "subjectId": 4,
        "sectionId": 46,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">Unit testing in Angular is the process of testing individual components, services, or functions in isolation to ensure they work correctly and make the application more reliable and maintainable.</span></p>",
                "subjectId": 4,
                "sectionId": 46,
                "subSectionId": -1,
                "contentId": 113,
                "text": "<p>What is Unit Testing in Angular, and why is it important?</p>"
            },
            {
                "description": "<p class=\"ql-align-justify\"><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Jasmine</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> is a testing framework, </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Karma</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> is a test runner (executes tests in browsers), and </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Jest</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> is an alternative framework+runner offering faster, simpler testing.</span></p></br><p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">In short: </span><em style=\"background-color: transparent; color: rgb(0, 0, 0);\">Jasmine + Karma work together</em><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, while </span><em style=\"background-color: transparent; color: rgb(0, 0, 0);\">Jest alone can replace both</em><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></p></br><p><strong>Jasmine: Jasmine</strong> is an <strong>open-source JavaScript testing framework</strong>.</p><p>A <strong>JavaScript testing framework</strong> provides the <strong>building blocks</strong> to write <strong>JavaScript unit test cases</strong>, ensuring that each <strong>line of code</strong> is properly <strong>unit tested</strong>.</p><p>It is used to <strong>test any type of JavaScript application</strong>.</p></br><p><strong>Karma:</strong> <strong>Karma</strong> is a <strong>testing automation tool</strong> created by the <strong>AngularJS team</strong>.</p><p><strong>Karma</strong> is an <strong>open-source tool</strong>.</p><p><strong>Karma allows us to execute test cases</strong> on <strong>any browser</strong>.</p>",
                "subjectId": 4,
                "sectionId": 46,
                "subSectionId": -1,
                "contentId": 114,
                "text": "<p>What testing frameworks are commonly used with Angular (Jasmine, Karma, Jest)?</p>"
            },
            {
                "description": "<p><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Unit testing</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> checks individual components/services in isolation, while </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">end-to-end testing</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> validates the entire application flow from the user‚Äôs perspective.</span></p>",
                "subjectId": 4,
                "sectionId": 46,
                "subSectionId": -1,
                "contentId": 115,
                "text": "<p>What is the difference between unit testing and end-to-end testing?</p>"
            },
            {
                "description": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">The default test runner in Angular projects created with Angular CLI is </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Karma</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></p>",
                "subjectId": 4,
                "sectionId": 46,
                "subSectionId": -1,
                "contentId": 116,
                "text": "<p>What is the default test runner in Angular projects created with Angular CLI?</p>"
            },
            {
                "description": "<p class=\"ql-align-justify\"><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">You can create a new Angular component with its spec (test) file using:</span></p><pre data-language=\"plain\">\nng generate component component-name\n</pre><p class=\"ql-align-justify\"></p><p class=\"ql-align-justify\"><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">üëâ The CLI automatically generates the </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">.spec.ts</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> test file.</span></p></br>",
                "subjectId": 4,
                "sectionId": 46,
                "subSectionId": -1,
                "contentId": 117,
                "text": "<p>How do you create a new Angular component test file using CLI?</p>"
            },
            {
                "description": "<p><strong>&#39;describe&#39;</strong> is a <strong>test suite</strong> (a <strong>folder</strong> or <strong>box</strong>) in <strong>Jasmine</strong>. It <strong>groups together related test cases</strong> (<strong>it blocks</strong>) and helps <strong>organize tests logically</strong>.</p>",
                "subjectId": 4,
                "sectionId": 46,
                "subSectionId": -1,
                "contentId": 118,
                "text": "<p>What is ‚Äòdescribe‚Äô in jasmine in Unit Testing?</p>"
            },
            {
                "description": "<p><strong>beforeEach</strong> is a <strong>special function</strong> provided by <strong>Jasmine</strong> (and <strong>Jest</strong>, <strong>Mocha</strong>, etc.). It <strong>runs before every</strong> <strong>‚Äòit‚Äô block</strong> (<strong>spec/test case</strong>) inside a <strong>describe block</strong>. It‚Äôs used to <strong>set up common code</strong> needed by <strong>multiple tests</strong>.</p>",
                "subjectId": 4,
                "sectionId": 46,
                "subSectionId": -1,
                "contentId": 119,
                "text": "<p>What is beforeEach in Jasmine?</p>"
            },
            {
                "description": "<p><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">TestBed</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">is the </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">primary Angular testing utility</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> that creates a </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">simulated Angular environment</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> for unit testing.</span></p></br><p><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">It allows us to test components, directives, pipes, and services </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">with Angular‚Äôs dependency injection, change detection, and templates</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">.</span></p></br><p class=\"ql-align-justify\"><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">1. </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">TestBed </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">Configures a testing module</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> (like a mini </span><span style=\"color: rgb(24, 128, 56); background-color: transparent;\">NgModule</span><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">):</span></p><pre data-language=\"plain\">\n\n  TestBed.configureTestingModule({\n  \tdeclarations: [MyComponent],\n  \tproviders: [MyService],\n \timports: [FormsModule, HttpClientTestingModule]\n   });\n</pre><p class=\"ql-align-justify\"></p><p class=\"ql-align-justify\"><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">2.</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> TestBed creates Components for testing:</span></p><pre data-language=\"plain\">\n\n   const fixture = TestBed.createComponent(MyComponent);\n   const component = fixture.componentInstance;\n   fixture.detectChanges(); // runs ngOnInit + bindings\n</pre></br><p>3. TestBed is used to Inject Services:</p><pre data-language=\"plain\">\n      \n    const service = TestBed.inject(MyService);\n\n</pre><p><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">4. Run Change Detection:</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> Updates the DOM after changing component properties.</span></p>",
                "subjectId": 4,
                "sectionId": 46,
                "subSectionId": -1,
                "contentId": 120,
                "text": "<p>What is TestBed in Angular Unit Testing?</p>"
            },
            {
                "description": "<p><strong>‚Äòit‚Äô</strong> defines a <strong>test case</strong>. It takes a <strong>description string</strong> that states the <strong>expected behavior</strong>, and a <strong>function</strong> that contains the <strong>test logic</strong> with <strong>expect</strong>.</p>",
                "subjectId": 4,
                "sectionId": 46,
                "subSectionId": -1,
                "contentId": 121,
                "text": "<p>What is ‚Äòit‚Äô in jasmine in Unit Testing?</p>"
            },
            {
                "description": "<p>In <strong>Angular unit testing</strong>, the <strong>expect</strong> function <strong>verifies</strong> that the <strong>actual result</strong> matches the <strong>expected result</strong> using <strong>matchers</strong>.</p>",
                "subjectId": 4,
                "sectionId": 46,
                "subSectionId": -1,
                "contentId": 122,
                "text": "<p>What is ‚Äòexpect‚Äô in Jasmin?</p>"
            },
            {
                "description": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">In Angular unit testing, a matcher function compares the actual result with the expected result.</span></p></br><p><strong>1.</strong> <strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">toBeTruthy:</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">.toBeTruthy()</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">checks that a value is not </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">false</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">0</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">&#39;&#39;</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">null</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">undefined</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, or </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">NaN</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></p></br><p><strong>2.</strong> <strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">toHaveBeenCalledWith: </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">toHaveBeenCalledWith</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">is a Jasmine matcher that checks if a spy (mocked function) was called with the expected arguments. </span> </p>",
                "subjectId": 4,
                "sectionId": 46,
                "subSectionId": -1,
                "contentId": 123,
                "text": "<p>Can you describe some matchers?</p>"
            },
            {
                "description": "<p><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">async</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">utility (renamed to </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">waitForAsync</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">) tracks all </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">pending async tasks</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> (Promises, timers, XHR) and waits until they are finished. Only then allows the test to continue and run expectations. It waits for </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">real async operations</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> to finish automatically.</span></p></br><pre data-language=\"plain\">\n\nmy.component.ts\n\nimport { Component, OnInit } from &#39;@angular/core&#39;;\n@Component({\n  selector: &#39;app-my&#39;,\n  template: `&lt;div *ngIf=&quot;data&quot;&gt;{{ data }}&lt;/div&gt;`\n})\nexport class MyComponent implements OnInit {\n  data: string | null = null;\n  ngOnInit(): void {\n    // Simulate async data (like HTTP call)\n    this.loadData().then(result =&gt; {\n      this.data = result;\n    });\n  }\n  loadData(): Promise&lt;string&gt; {\n    return new Promise(resolve =&gt; {\n      setTimeout(() =&gt; resolve(&#39;Hello Async Data!&#39;), 500);\n    });\n  }\n}\n</pre></br><pre data-language=\"plain\">\n\n// my.component.spec.ts\n\nit(&#39;should load data async and render it&#39;, waitForAsync(() =&gt; {\n fixture.detectChanges(); // triggers ngOnInit\n fixture.whenStable().then(() =&gt; {\n fixture.detectChanges(); // update view after async resolves\n const div = fixture.debugElement.query(By.css(&#39;div&#39;)).nativeElement;\n expect(div.textContent).toContain(&#39;Hello Async Data!&#39;);\n expect(component.data).toBe(&#39;Hello Async Data!&#39;);\n });\n</pre></br><p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">üîë</span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> What happens here:</strong></p></br><p><strong>1.</strong> <strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">fixture.detectChanges():</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> triggers </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">ngOnInit</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">, which starts an async task.</span></p></br><p><strong>2.</strong> <strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">fixture.whenStable():</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> waits until </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">all Promises &amp; async tasks are finished</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">.</span></p></br><p><strong>3.</strong> <strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">fixture.detectChanges():</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> refreshes template after data is set.</span></p></br><p><strong>4.</strong> <span style=\"color: rgb(0, 0, 0); background-color: transparent;\">Test asserts that </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">async data is rendered</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">.</span></p></br><p><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">Explain:</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </span></p><p><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">I created a </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">loadData</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">function that returns a Promise and resolved this Promise inside </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">ngOnInit()</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">, storing the result in a </span><span style=\"color: rgb(24, 128, 56); background-color: transparent;\">data</span><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> property.</span></p></br><p><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">For the unit test: I created a </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">loadData</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">function which returns a Promise and resolved this Promise in </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">ngOnInit()</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">, then stored the result in the </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">data</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">property. I wrote a unit test case for this. I used </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">TestBed.createComponent</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> to create a fixture for the component, which provides the setup before running the tests, and I accessed the component instance using </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">fixture.componentInstance</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">.</span></p></br><p><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">Inside the </span><span style=\"color: rgb(24, 128, 56); background-color: transparent;\">it</span><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> block for </span><em style=\"color: rgb(0, 0, 0); background-color: transparent;\">&#39;should load data async and render it&#39;</em><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">, I wrapped the test with the </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">waitForAsync</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">function. First, I ran</span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">fixture.detectChanges()</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> to update the view. Then I used </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">fixture.whenStable()</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> to wait until the component became stable. After that, I got the </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">div</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">element‚Äôs </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">nativeElement</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">using </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">fixture.debugElement.query(By.css(&#39;div&#39;)).nativeElement</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">. Finally, I compared </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">div.textContent</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> and </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">component.data</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> with</span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">&#39;Hello Async Data&#39;</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">.</span></p>",
                "subjectId": 4,
                "sectionId": 46,
                "subSectionId": -1,
                "contentId": 124,
                "text": "<p>How does <span style=\"color: rgb(0, 138, 0);\">async </span>work in Angular testing?</p>"
            },
            {
                "description": "<p><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">fakeAsync</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">utility tests asynchronous code </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">synchronously</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> by simulating the passage of time.</span></p></br><p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">When you wrap a test function in </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">fakeAsync</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, Angular runs it and replaces real async functions </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">(</strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setTimeout</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setInterval</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">Promise.then</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, RxJS timers, etc.) with </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">mocked versions</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></p></br><pre data-language=\"plain\">\n\nfake-async.component.ts\n\nimport { Component, OnInit } from &#39;@angular/core&#39;;\n@Component({\n  selector: &#39;app-fake-async&#39;,\n  template: `\n    &lt;div&gt;Static Div&lt;/div&gt;\n    &lt;div *ngIf=&quot;data&quot;&gt;{{ data }}&lt;/div&gt;\n    &lt;div&gt;Another Div&lt;/div&gt;\n  `\n})\nexport class FakeAsyncComponent implements OnInit {\n  data: string | null = null;\n  ngOnInit(): void {\n    setTimeout(() =&gt; {\n      this.data = &#39;Hello FakeAsync!&#39;;\n    }, 1000);\n  }\n}\n</pre></br><pre data-language=\"plain\">\n\nit(&#39;should load async data into the second div&#39;, fakeAsync(() =&gt; {\n    fixture.detectChanges(); // triggers ngOnInit\n    expect(component.data).toBeNull();\n    tick(1000);              // simulate passage of 1 second\n    fixture.detectChanges();\n    const divs = fixture.debugElement.queryAll(By.css(&#39;div&#39;));\n    expect(divs.length).toBe(3);\n    // Second div contains async data\n    expect(divs[1].nativeElement.textContent).toContain(&#39;Hello FakeAsync!&#39;);\n    expect(component.data).toBe(&#39;Hello FakeAsync!&#39;);\n  }));\n</pre></br><p><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Note:</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> Don‚Äôt use fixture.detectChanges(); in beforeEach() otherwise we will get an error.</span></p>",
                "subjectId": 4,
                "sectionId": 46,
                "subSectionId": -1,
                "contentId": 125,
                "text": "<p>How does <span style=\"color: rgb(0, 138, 0);\">fakeAsync </span>work in Angular testing?</p>"
            },
            {
                "description": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">Both </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">tick()</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> and </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">flush()</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> are used </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">inside </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">fakeAsync</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> tests</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> to control virtual time and execute async tasks.</span></p></br><p><strong>1.</strong>  <strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">tick()</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> is a helper function that works only inside a </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">fakeAsync</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> zone</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">. It </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">simulates the passage of virtual time</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, allowing scheduled async tasks </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">(</strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setTimeout</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setInterval</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, RxJS timers, Promises, etc.) to be executed </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">without waiting in real time</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></p></br><p><strong>2.</strong>  <strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">flush()</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> is a helper function that works only inside a </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">fakeAsync</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">zone. It executes all pending timers at once, without needing any arguments, and moves the virtual clock forward until all queued timers (macroTasks like </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setTimeout</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">and </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setInterval</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">) are executed.</span></p>",
                "subjectId": 4,
                "sectionId": 46,
                "subSectionId": -1,
                "contentId": 126,
                "text": "<p>What is the difference between<span style=\"color: rgb(0, 138, 0);\"> tick()</span> and <span style=\"color: rgb(0, 138, 0);\">flush()</span> in Angular tests?</p>"
            },
            {
                "description": "<p><strong>ComponentFixture</strong> allows us to:</p><ul><li><strong>Access the component instance</strong></li><li><strong>Access the native DOM element</strong> using <code><strong>fixture.nativeElement</strong></code> for <strong>DOM testing</strong></li><li><strong>Trigger change detection</strong> using <code><strong>fixture.detectChanges()</strong></code></li></ul></br>",
                "subjectId": 4,
                "sectionId": 46,
                "subSectionId": -1,
                "contentId": 127,
                "text": "<p>What is <span style=\"color: rgb(0, 138, 0);\">ComponentFixture</span> in Angular testing, and why is it used?</p>"
            },
            {
                "description": "<p><code><strong>spyOn()</strong></code> is used to <strong>spy on an existing method</strong> of a <strong>real object or service</strong>.</p><p>It tracks calls, arguments, and return values ‚Äî and optionally allows you to mock its behavior.</p></br><p><strong>getSum method is called from component&#39;s ngOnInit with parameters:</strong></p><pre data-language=\"plain\">\n  it(&#39;should call getSum method from UserService&#39;, () =&gt; {\n    const userService = TestBed.inject(UserService);\n    const spy = spyOn(userService, &#39;getSum&#39;).and.callThrough();\n    component.ngOnInit();\n    expect(spy).toHaveBeenCalledOnceWith(5, 7);\n  });\n</pre></br><p><strong>getSum method is called from component&#39;s ngOnInit without parameters:</strong></p><pre data-language=\"plain\">\n it(&#39;should call getSum method from UserService&#39;, () =&gt; {\n    const userService = TestBed.inject(UserService);\n    const spy = spyOn(userService, &#39;getSum&#39;).and.callThrough();\n    component.ngOnInit();\n    expect(spy).toHaveBeenCalled();\n  });\n</pre></br><p><strong>getSum method is called from component&#39;s ngOnInit and return value 7:</strong></p><pre data-language=\"plain\">\nit(&#39;should set sum with the value returned from getSum&#39;, () =&gt; {\n    spyOn(userService, &#39;getSum&#39;).and.returnValue(7);\n    fixture.detectChanges(); // triggers ngOnInit()\n    expect(component.sum).toBe(7);\n  });\n</pre></br><p>‚úÖ <strong>Key Points:</strong></p><ul><li>Works on <strong>existing objects</strong>.</li><li>Replaces only the <strong>specific method</strong> you spy on.</li><li>You can <strong>mock return values</strong> or <strong>verify calls</strong>.</li></ul></br><p><strong>‚ÄúUsed to spy‚Äù</strong> means <strong>to watch, track, or monitor a function‚Äôs behavior</strong> during a test ‚Äî <strong>without actually running its real implementation</strong></p>",
                "subjectId": 4,
                "sectionId": 46,
                "subSectionId": -1,
                "contentId": 128,
                "text": "<p><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">What is the use of </span><span style=\"color: rgb(24, 128, 56); background-color: transparent;\">spyOn()</span><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> in Jasmine?</span></p>"
            },
            {
                "description": "<p><code><strong>createSpyObject()</strong></code> is used to <strong>create a completely fake object</strong> with one or more <strong>spy methods</strong> ‚Äî without needing a real class or instance.</p></br><pre data-language=\"plain\">\nit(&#39;should call save method of mock service&#39;, () =&gt; {\n  const mockService = jasmine.createSpyObj(&#39;UserService&#39;, [&#39;save&#39;]);\n  mockService.save.and.returnValue(of(true));\n\n  component = new UserComponent(mockService);\n  component.saveUser();\n\n  expect(mockService.save).toHaveBeenCalled();\n});\n</pre></br><p>‚úÖ <strong>Key Points:</strong></p><ul><li>Creates a <strong>mock object from scratch</strong>.</li><li>Ideal when you want <strong>complete control</strong> over dependencies.</li><li>Doesn‚Äôt require the <strong>real class</strong> or <strong>Angular TestBed</strong>.</li></ul></br>",
                "subjectId": 4,
                "sectionId": 46,
                "subSectionId": -1,
                "contentId": 129,
                "text": "<p>What is the use of createSpyObject() in Jasmine?</p>"
            }
        ]
    },
    {
        "name": "<p><strong>Scenario Based Questions</strong></p>",
        "subjectId": 4,
        "sectionId": 47,
        "subSectionId": -1,
        "subSections": [
            {
                "name": "<p><strong>Mock a Service</strong></p>",
                "sectionId": 47,
                "subSectionId": 125,
                "subjectId": 4,
                "contents": [
                    {
                        "text": "<p>If a service method is called from a component, how many ways can we mock the service in unit testing?</p>",
                        "sectionId": 47,
                        "subSectionId": 125,
                        "subjectId": 4,
                        "contentId": 419,
                        "description": "<p>There are multiple ways to mock a service in Angular unit tests.</p><p><strong>First</strong>, we can create a mock class and provide it using <code>useClass</code>.</p></br><p><strong>Second</strong>, we can create a Jasmine spy object using <code>jasmine.createSpyObj</code> and override methods dynamically.</p></br><p><strong>Third</strong>, we can provide a simple mock object with <code>useValue</code>.</p></br><p><strong>Fourth</strong>, if the service uses HTTP, we can use <code>HttpClientTestingModule</code> and mock API calls instead of mocking the service itself.</p></br><p>These approaches give flexibility depending on how complex the service is and how much control we need over the return values.</p>"
                    },
                    {
                        "description": "<p>I replaced the real <strong>UserService </strong>with a <strong>MockUserService </strong>using <code>useClass</code>. The <strong>mock </strong>returns controlled <strong>observable data</strong>. In my tests, I verify the <strong>component </strong>is created, check if <code>getUsers()</code> was called during <strong>ngOnInit</strong>, <strong>validate </strong>that the <strong>component </strong>received the <strong>mock data</strong>, and finally ensure the <strong>template </strong>renders the <strong>correct values</strong>. This proves that the <strong>component </strong>behaves correctly with the <strong>mocked dependency</strong>.</p></br><pre data-language=\"plain\">\n// UserService (original service)\n\nexport class UserService {\n  getUsers() {\n    return of([&#39;Real User 1&#39;, &#39;Real User 2&#39;]);\n  }\n}\n</pre></br><pre data-language=\"plain\">\n// Component that depends on UserService\n\n@Component({\n  selector: &#39;app-user-list&#39;,\n  template: `&lt;div *ngFor=&quot;let u of users&quot;&gt;{{ u }}&lt;/div&gt;`\n})\nexport class UserListComponent {\n  users: string[] = [];\n\n  constructor(private userService: UserService) {}\n\n  ngOnInit() {\n    this.userService.getUsers().subscribe(res =&gt; {\n      this.users = res;\n    });\n  }\n}\n</pre></br><pre data-language=\"plain\">\n// Mock Class (Fake Service)\n\nclass MockUserService {\n  getUsers() {\n    return of([&#39;Vivek&#39;, &#39;Rahul&#39;]);\n  }\n}\n</pre></br><pre data-language=\"plain\">\n// Unit Test Using Mock Class\n\nimport { ComponentFixture, TestBed } from &#39;@angular/core/testing&#39;;\nimport { UserListComponent } from &#39;./user-list.component&#39;;\nimport { UserService } from &#39;./user.service&#39;;\nimport { of } from &#39;rxjs&#39;;\nimport { By } from &#39;@angular/platform-browser&#39;;\n\ndescribe(&#39;UserListComponent with Mock Class&#39;, () =&gt; {\n  let component: UserListComponent;\n  let fixture: ComponentFixture&lt;UserListComponent&gt;;\n\n  beforeEach(async () =&gt; {\n    await TestBed.configureTestingModule({\n      declarations: [UserListComponent],\n      providers: [\n        { provide: UserService, useClass: MockUserService }\n      ]\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(UserListComponent);\n    component = fixture.componentInstance;\n  });\n\n  // ‚úÖ Test 1: Component should be created\n  it(&#39;should create the component&#39;, () =&gt; {\n    expect(component).toBeTruthy();\n  });\n\n  // ‚úÖ Test 2: Should call getUsers() on init\n  it(&#39;should call getUsers on ngOnInit&#39;, () =&gt; {\n    const userService = TestBed.inject(UserService);\n    spyOn(userService, &#39;getUsers&#39;).and.callThrough();\n\n    component.ngOnInit();\n\n    expect(userService.getUsers).toHaveBeenCalled();\n  });\n\n  // ‚úÖ Test 3: Should load users from mock service\n  it(&#39;should load users from mock service&#39;, () =&gt; {\n    component.ngOnInit();\n    expect(component.users).toEqual([&#39;Vivek&#39;, &#39;Rahul&#39;]);\n  });\n\n  // ‚úÖ Test 4: Should render list in template\n  it(&#39;should render user list in DOM&#39;, () =&gt; {\n    component.ngOnInit();\n    fixture.detectChanges(); // update template\n\n    const divs = fixture.debugElement.queryAll(By.css(&#39;div&#39;));\n    const textValues = divs.map(d =&gt; d.nativeElement.textContent.trim());\n\n    expect(textValues).toEqual([&#39;Vivek&#39;, &#39;Rahul&#39;]);\n  });\n});\n</pre></br>",
                        "subjectId": 4,
                        "sectionId": 47,
                        "subSectionId": 125,
                        "contentId": 132,
                        "text": "<p>Writing unit test cases using a<strong> Mock Class</strong>.</p>"
                    },
                    {
                        "description": "<p><strong>spyOn</strong>:</p><p><span style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\">Here I will describe the fixture and component for </span><code style=\"color: rgb(0, 0, 0); background-color: rgb(236, 236, 236);\">Current Component</code><span style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\"> using </span><code style=\"color: rgb(0, 0, 0); background-color: rgb(236, 236, 236);\">TestBed.createComponent(Parent)</code><span style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\"> for the fixture and </span><code style=\"color: rgb(0, 0, 0); background-color: rgb(236, 236, 236);\">fixture.componentInstance</code><span style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\"> for the component instance. Then I inject service to pass service into </span><code style=\"color: rgb(0, 0, 0); background-color: rgb(236, 236, 236);\">TestBed.inject()</code>.</p></br><p>We mock the service method using <code style=\"background-color: rgb(236, 236, 236); color: rgb(0, 0, 0);\">spyOn()</code> so no real API is called.</p><p>Then we trigger the component function that uses the service.</p><p>If the service is called with a single parameter, then I will check using:</p><p><code> expect(userService.getUserDetail).toHaveBeenCalledWith(1);</code></p><p>If the service is called with multiple parameters, then I will check using:</p><p><code> expect(userService.multiplyTwoNumber).toHaveBeenCalledWith(5, 13);</code></p></br><p>Link: <a href=\"https://github.com/777Vikki/Angular-Unit-Testing/blob/2-call-service-from-component-spyOn/src/app/app.spec.ts\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/777Vikki/Angular-Unit-Testing/blob/2-call-service-from-component-spyOn/src/app/app.spec.ts</a></p></br><p><strong>createSpyObj</strong>:</p><p><a href=\"https://github.com/777Vikki/Angular-Unit-Testing/blob/3-call-service-from-component-createSpyObj/src/app/app.spec.ts\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/777Vikki/Angular-Unit-Testing/blob/3-call-service-from-component-createSpyObj/src/app/app.spec.ts</a></p>",
                        "subjectId": 4,
                        "sectionId": 47,
                        "subSectionId": 125,
                        "contentId": 133,
                        "text": "<p>How do you test a service call inside a component in Angular?</p>"
                    }
                ],
                "subSections": []
            }
        ],
        "contents": [
            {
                "description": "<p>To verify that a <strong>component </strong>is created, I first configure the <strong>TestBed </strong>and create a <strong>fixture </strong>using <code>TestBed.createComponent()</code>. The <strong>fixture </strong>gives me access to the <strong>component instance </strong>through <code>fixture.componentInstance</code>. If the <strong>component </strong>is successfully created by <strong>Angular</strong>, that <strong>instance </strong>will be <strong>truthy</strong>. So in the test, I simply check <code>expect(component).toBeTruthy()</code>. If this passes, it confirms that <strong>Angular </strong>was able to construct the <strong>component </strong>along with all its <strong>dependencies</strong>.</p></br><pre data-language=\"plain\">\n// ts file\nimport { ComponentFixture, TestBed } from &#39;@angular/core/testing&#39;;\nimport { MyComponent } from &#39;./my.component&#39;;\n\ndescribe(&#39;MyComponent&#39;, () =&gt; {\n  let component: MyComponent;\n  let fixture: ComponentFixture&lt;MyComponent&gt;;\n\n  beforeEach(async () =&gt; {\n    await TestBed.configureTestingModule({\n      declarations: [MyComponent]\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(MyComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it(&#39;should create the component&#39;, () =&gt; {\n    expect(component).toBeTruthy();\n  });\n});\n</pre></br>",
                "subjectId": 4,
                "sectionId": 47,
                "subSectionId": -1,
                "contentId": 130,
                "text": "<p>How do we verify that a component is created?</p>"
            },
            {
                "description": "<p>To verify @Input() binding, I create the parent component using TestBed. Then I set the parent‚Äôs property and call <code>fixture.detectChanges()</code> so Angular updates the bindings. I use <code>By.directive(ChildComponent)</code> to get the child component instance from the DOM. Finally, I assert that the child‚Äôs <code>data</code> input matches the value from the parent. This confirms that the parent is correctly passing @Input values.</p></br><pre data-language=\"plain\">\nimport { ComponentFixture, TestBed } from &#39;@angular/core/testing&#39;;\nimport { ParentComponent } from &#39;./parent.component&#39;;\nimport { ChildComponent } from &#39;./child.component&#39;;\nimport { By } from &#39;@angular/platform-browser&#39;;\n\ndescribe(&#39;ParentComponent&#39;, () =&gt; {\n  let fixture: ComponentFixture&lt;ParentComponent&gt;;\n  let parent: ParentComponent;\n\n  beforeEach(async () =&gt; {\n    await TestBed.configureTestingModule({\n      declarations: [ParentComponent, ChildComponent]\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(ParentComponent);\n    parent = fixture.componentInstance;\n  });\n\n  it(&#39;should pass the correct value to the child&#39;, () =&gt; {\n    parent.parentValue = &#39;Hello Child&#39;;\n    fixture.detectChanges(); // triggers Angular input binding\n\n    const childDebugEl = fixture.debugElement.query(By.directive(ChildComponent));\n    const childComponent = childDebugEl.componentInstance as ChildComponent;\n\n    expect(childComponent.data).toBe(&#39;Hello Child&#39;);\n  });\n});\n</pre></br>",
                "subjectId": 4,
                "sectionId": 47,
                "subSectionId": -1,
                "contentId": 131,
                "text": "<p>Suppose you have a parent component passing a value to a child component via <code>@Input()</code>. How would you write a unit test to verify that the child receives the correct value?</p>"
            },
            {
                "text": "<p>Suppose you have a child component emits a value to a parent component via <code>@Output()</code>. How would you write a unit test to verify that the child emits the correct value?</p>",
                "sectionId": 47,
                "subSectionId": -1,
                "subjectId": 4,
                "contentId": 418,
                "description": "<pre data-language=\"plain\">\n@Output() valueChanged = new EventEmitter&lt;string&gt;();\n\nemitValue() {\n  this.valueChanged.emit(&#39;Hello Parent&#39;);\n}\n</pre></br><p><strong>Method 1: Testing @Output() in the Child Component Itself</strong></p><p>To test an Output(), I create the child component and spy on its EventEmitter‚Äôs <code>emit()</code> method. Then I call the function that emits the event, and finally assert that <code>emit()</code> was called with the expected value.</p><pre data-language=\"plain\">\nit(&#39;should emit the correct value&#39;, () =&gt; {\n  const fixture = TestBed.createComponent(ChildComponent);\n  const component = fixture.componentInstance;\n\n  spyOn(component.valueChanged, &#39;emit&#39;);\n\n  component.emitValue(); // action that triggers @Output\n\n  expect(component.valueChanged.emit).toHaveBeenCalledWith(&#39;Hello Parent&#39;);\n});\n</pre></br><p><strong>Method 2: Testing @Output() Emission at the Parent Level (More Impressive)</strong></p><p>If I want to verify not just that the child emits but also that the parent receives the value, I create the parent component, grab the child through <code>fixture.debugElement</code>, trigger the child‚Äôs EventEmitter manually, and assert that the parent‚Äôs handler updates its state accordingly. This ensures the full parent‚Äìchild communication works as expected.</p><pre data-language=\"plain\">\nit(&#39;should receive emitted value from the child&#39;, () =&gt; {\n  const fixture = TestBed.createComponent(ParentComponent);\n  const parent = fixture.componentInstance;\n  fixture.detectChanges();\n\n  const childDebug = fixture.debugElement.query(By.directive(ChildComponent));\n  const childComponent = childDebug.componentInstance as ChildComponent;\n\n  childComponent.valueChanged.emit(&#39;Testing Output&#39;);\n  fixture.detectChanges();\n\n  expect(parent.receivedValue).toBe(&#39;Testing Output&#39;);\n});\n</pre></br>"
            },
            {
                "description": "<p>When testing HTTP-based services, we use <code>HttpTestingController</code> from <code>HttpClientTestingModule</code> to intercept and mock HTTP requests. It allows us to test the service logic without making real API calls. We verify requests using <code>expectOne()</code>, provide mock data using <code>flush()</code>, and ensure no pending requests remain using <code>verify()</code>.</p></br><p>Link: <a href=\"https://github.com/777Vikki/Angular-Unit-Testing/blob/4-verify-http-in-service/src/app/user-service.spec.ts\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/777Vikki/Angular-Unit-Testing/blob/4-verify-http-in-service/src/app/user-service.spec.ts</a></p>",
                "subjectId": 4,
                "sectionId": 47,
                "subSectionId": -1,
                "contentId": 134,
                "text": "<p>Suppose your service calls an API using <code>HttpClient.get()</code>. How would you write a test for it using <code>HttpTestingController</code>?</p>"
            },
            {
                "description": "<p><strong>‚úÖ 1. Using By.css(&#39;#getUserDetailBtn&#39;):</strong></p><pre data-language=\"plain\">\nimport { By } from &quot;@angular/platform-browser&quot;\n\nit(&#39;should call getUserDetail when button is clicked&#39;, () =&gt; {\n  const spy = spyOn(component, &#39;getUserDetail&#39;);\n\n  const btn = fixture.debugElement.query(By.css(&#39;#getUserDetailBtn&#39;));\n  btn.triggerEventHandler(&#39;click&#39;, null);\n\n  expect(spy).toHaveBeenCalled();\n});\n</pre></br><p><code>fixture.debugElement.query(By.css(&#39;#getUserDetailBtn&#39;))</code> is used to <strong>find an element from the component‚Äôs template during unit testing</strong>.</p></br><p><strong>‚úÖ 2. Using nativeElement (not recommended but valid):</strong></p><pre data-language=\"plain\">\nit(&#39;should call getUserDetail when button clicked&#39;, () =&gt; {\n  const spy = spyOn(component, &#39;getUserDetail&#39;);\n\n  const btn: HTMLButtonElement =\n    fixture.nativeElement.querySelector(&#39;#getUserDetailBtn&#39;);\n  btn.click();\n\n  expect(spy).toHaveBeenCalled();\n});\n</pre></br><p><strong>Note:</strong> Use <code>By.css()</code> because it works consistently with Angular‚Äôs change detection and DebugElement.</p>",
                "subjectId": 4,
                "sectionId": 47,
                "subSectionId": -1,
                "contentId": 135,
                "text": "<p>How do you simulate a click event in Angular unit tests?</p>"
            }
        ]
    }
]