[
    {
        "name": "<p><strong>Introduction, Type and Interface</strong></p>",
        "subjectId": 8,
        "sectionId": 67,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "<p><strong>TypeScript </strong>is a <strong>superset </strong>of <strong>JavaScript</strong>. <strong>JavaScript </strong>is powerful, but it has some limitations when <strong>projects </strong>become <strong>large </strong>and <strong>complex</strong>. <strong>TypeScript </strong>was introduced to solve those issues and make <strong>JavaScript </strong>development more <strong>scalable</strong>, <strong>maintainable</strong>, and <strong>less error-prone</strong>.</p></br><p><strong>1. Type Safety &amp; Early Error Detection:</strong></p><p><strong>JavaScript </strong>is <strong>dynamically typed</strong>, so many <strong>errors </strong>appear only at <strong>runtime</strong>. <strong>TypeScript </strong>adds <strong>static typing</strong>, which catches <strong>errors <em>during development</em></strong>.</p></br><p><strong>2. Better Tooling &amp; Developer Productivity: </strong>TypeScript provides: <strong>Intelligent auto-completion, Real-time type checking, Refactoring support, Improved code navigation. </strong></p><p>This significantly improves productivity and reduces debugging time.</p></br><p><strong>3.  Helps in Building Large-Scale Applications: </strong>In <strong>big applications </strong>(like <strong>Angular apps</strong>), managing and understanding code becomes hard. <strong>Interfaces</strong>, <strong>Generics</strong>, <strong>Enums </strong>and <strong>Access modifiers</strong>.</p><p>These help <strong>structure </strong>and <strong>scale applications properly</strong>.</p></br><p><strong>TypeScript </strong>was introduced to make <strong>JavaScript development safer</strong>, <strong>more organized</strong>, and <strong>scalable</strong>—especially for<strong> large enterprise applications</strong>.</p>",
                "subjectId": 8,
                "sectionId": 67,
                "subSectionId": -1,
                "contentId": 205,
                "text": "<p><strong>Why did we introduce typescript, we have JavaScript?</strong></p>"
            },
            {
                "description": "<p>Both <strong>type</strong> and <strong>interface</strong> are used in <strong>TypeScript </strong>to define the<strong> shape of objects</strong>, but they are not exactly the same.</p></br><p><strong>Interfaces </strong>are best for defining <strong>object shapes</strong> and can be extended or merged easily. Type <strong>aliases </strong>are more flexible and can represent <strong>unions</strong>, <strong>intersections</strong>, <strong>primitives</strong>, and <strong>complex types</strong>. Use <strong>interface </strong>for object models; use <strong>type </strong>when you need more advanced type compositions.</p></br><p><strong>Example of Type</strong></p><p><strong>1. Type for an object</strong></p><pre data-language=\"plain\">\ntype User = {\n  id: number;\n  name: string;\n  isActive: boolean;\n};\n</pre></br><p><strong>2. Type alias for primitive values</strong></p><pre data-language=\"plain\">\ntype ID = number | string;\n</pre></br><p><strong>3. Type alias for functions</strong></p><pre data-language=\"plain\">\ntype Callback = (message: string) =&gt; void;\n</pre></br><p><strong>4. Type alias for tuples</strong></p><pre data-language=\"plain\">\ntype Point = [number, number];\n</pre></br><p><strong>5. Type alias for union &amp; intersection types</strong></p><pre data-language=\"plain\">\ntype Status = &quot;success&quot; | &quot;error&quot; | &quot;loading&quot;;\ntype Employee = User &amp; { salary: number };\n</pre></br><p><strong>Example of interface</strong></p><p><strong>1. Basic Interface Example</strong></p><pre data-language=\"plain\">\ninterface User {\n  id: number;\n  name: string;\n  isActive: boolean;\n}\n</pre><p><strong>Purpose:</strong> Defines the shape of an object.</p></br><p><strong>2. Interface with Optional Properties</strong></p><pre data-language=\"plain\">\ninterface Employee {\n  id: number;\n  name: string;\n  salary?: number;  // optional\n}\n</pre></br><p><strong>3. Interface with Readonly Properties</strong></p><pre data-language=\"plain\">\ninterface Product {\n  readonly id: number;\n  name: string;\n}\n</pre><p><strong>Purpose:</strong> Prevents modification.</p></br><p><strong>4. Interface with Functions</strong></p><pre data-language=\"plain\">\ninterface Logger {\n  log(message: string): void;\n}\n\nconst consoleLogger: Logger = {\n  log(msg) {\n    console.log(&quot;Log:&quot;, msg);\n  }\n};\n</pre><p><strong>Purpose:</strong> Defines a contract for functions.</p></br><p><strong>5. Interface Extending Another Interface</strong></p><pre data-language=\"plain\">\ninterface Person {\n  name: string;\n  age: number;\n}\n\ninterface Developer extends Person {\n  skills: string[];\n}\n</pre><p><strong>Purpose:</strong> Inheritance between interfaces.</p></br><p><strong>6. Using Interface with Classes</strong></p><pre data-language=\"plain\">\ninterface Printable {\n  print(): void;\n}\n\nclass Report implements Printable {\n  print() {\n    console.log(&quot;Printing report...&quot;);\n  }\n}\n</pre><p><strong>Purpose:</strong> Enforces that class implements specific methods.</p></br><p><strong>7. Interface for Array Structure</strong></p><pre data-language=\"plain\">\ninterface StringArray {\n  [index: number]: string;\n}\n\nconst names: StringArray = [&quot;Amit&quot;, &quot;Ravi&quot;, &quot;Sohan&quot;];\n</pre><p><strong>Purpose:</strong> Index signature for arrays.</p></br><p><strong>8. Interface with Multiple Index Signatures</strong></p><pre data-language=\"plain\">\ninterface Dictionary {\n  [key: string]: number;\n}\n\nconst scores: Dictionary = {\n  vipin: 95,\n  amit: 88,\n};\n</pre>",
                "subjectId": 8,
                "sectionId": 67,
                "subSectionId": -1,
                "contentId": 206,
                "text": "<p><strong>Difference between type vs interface and when to use each.</strong></p>"
            }
        ]
    },
    {
        "name": "<p><strong>Omit, keyof, Access Modifiers, Generics, Decorators, Tuple, Enums</strong></p>",
        "sectionId": 101,
        "subSectionId": -1,
        "subjectId": 8,
        "contents": [],
        "subSections": [
            {
                "name": "<p><strong>Omit</strong></p>",
                "sectionId": 101,
                "subSectionId": 118,
                "subjectId": 8,
                "contents": [
                    {
                        "text": "<p>What is <strong>Omit </strong>in <strong>TypeScript</strong>?</p>",
                        "sectionId": 101,
                        "subSectionId": 118,
                        "subjectId": 8,
                        "contentId": 406,
                        "description": "<p><code>Omit</code> is a <strong>TypeScript </strong>utility type used to create a new type by removing specific properties from an existing type.</p><p>It&#39;s useful when you want to reuse a <strong>model </strong>but exclude certain fields—like removing <code>password</code> from a User <strong>type</strong>, or <strong>removing</strong> <code>id</code> when sending <strong>create/update</strong> requests in Angular. It improves type safety and reduces repeated code.</p></br><pre data-language=\"plain\">\nOmit&lt;Type, &#39;key1&#39; | &#39;key2&#39;&gt;\n</pre></br><pre data-language=\"plain\">\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  password: string;\n}\n\ntype UserWithoutPassword = Omit&lt;User, &#39;password&#39;&gt;;\ntype UserWithoutPasswordEmail = Omit&lt;User, &#39;password&#39; | &#39;email&#39;&gt;;\n</pre>"
                    }
                ],
                "subSections": []
            },
            {
                "name": "<p><strong>keyof</strong></p>",
                "sectionId": 101,
                "subSectionId": 119,
                "subjectId": 8,
                "contents": [
                    {
                        "text": "<p>What is <strong>keyof </strong>in <strong>TypeScript</strong>?</p>",
                        "sectionId": 101,
                        "subSectionId": 119,
                        "subjectId": 8,
                        "contentId": 407,
                        "description": "<p>In TypeScript, <code><strong>keyof</strong></code><strong> is a type operator that takes an object type and returns a union of its keys.</strong></p><pre data-language=\"plain\">\ninterface User {\n  name: string;\n  email: string;\n  age: number;\n}\n\ntype UserKeys = keyof User;\n</pre></br><pre data-language=\"plain\">\n// UserKeys = &quot;name&quot; | &quot;email&quot; | &quot;age&quot;\n</pre></br></br>"
                    }
                ],
                "subSections": []
            },
            {
                "name": "<p><strong>Access Modifiers</strong></p>",
                "sectionId": 101,
                "subSectionId": 128,
                "subjectId": 8,
                "contents": [
                    {
                        "description": "<p><code>any</code> disables all type checking, so <strong>TypeScript </strong>won’t warn you about incorrect operations.</p></br><p><code>unknown</code> is similar to <code>any</code> in accepting all values, but it forces you to check the type before using it, making it safer.</p></br><p><code>never</code> represents a value that can never occur — usually used for functions that never return or to enforce exhaustive checks.</p>",
                        "subjectId": 8,
                        "sectionId": 101,
                        "subSectionId": 128,
                        "contentId": 207,
                        "text": "<p><strong>Difference between any, unknown, never.</strong></p>"
                    }
                ],
                "subSections": []
            },
            {
                "name": "<p><strong>Generics</strong></p>",
                "sectionId": 101,
                "subSectionId": 129,
                "subjectId": 8,
                "contents": [
                    {
                        "description": "<p><strong>Generics </strong>are needed to write <strong>reusable </strong>and <strong>type-safe</strong> code in <strong>TypeScript</strong>.</p></br><p>They let us create <strong>functions </strong>and <strong>services </strong>that work with any data type without losing type information.</p></br><p>A very common real example is <strong>Angular&#39;s HttpClient</strong>, where we specify the expected response type using <strong>generics</strong>, like <code>this.http.get&lt;User[]&gt;(&#39;/api&#39;)</code>.</p></br><p>In my projects, I create a <strong>generic API </strong>service using <code>get&lt;T&gt;()</code> and <code>post&lt;T&gt;()</code> to return strongly typed data across all <strong>services</strong>.</p></br><p>This improves <strong>maintainability</strong>, <strong>avoids runtime errors</strong>, and gives <strong>better IntelliSense</strong>.</p></br><p>&lt;T&gt; means <strong>Generic </strong>T in <strong>angle brackets</strong></p></br><pre data-language=\"plain\">\n// Instead of this (unsafe, returns any):\nthis.http.get(&#39;api/users&#39;);\n\n// We use Generics (safe, typed):\nthis.http.get&lt;User[]&gt;(&#39;api/users&#39;).subscribe(users =&gt; {\n  console.log(users[0].name); // ✅ Type-safe\n});\n</pre>",
                        "subjectId": 8,
                        "sectionId": 101,
                        "subSectionId": 129,
                        "contentId": 208,
                        "text": "<p><strong>Generics – why needed, real example with Angular services (e.g., HttpClient).</strong></p>"
                    }
                ],
                "subSections": []
            },
            {
                "name": "<p><strong>Decorators</strong></p>",
                "sectionId": 101,
                "subSectionId": 130,
                "subjectId": 8,
                "contents": [
                    {
                        "description": "<p><strong>Decorators </strong>in <strong>TypeScript </strong>are special functions <strong>prefixed </strong>with <code>@</code> that allow us to <strong>add metadata</strong>, <strong>modify behavior</strong>, or <strong>configure classes</strong>, <strong>methods</strong>, <strong>properties</strong>, and <strong>parameters </strong>at design time.</p></br><p><strong>Types of Decorators in Angular</strong></p><p><strong>1. Class Decorators: </strong>Used to tell Angular what type of class it is.</p><ul><li><code>@Component</code> → marks a class as a component</li><li><code>@Directive</code> → custom directives</li><li><code>@Pipe</code> → custom pipe</li><li><code>@Injectable</code> → marks a class as a service and enables DI</li></ul></br><p><strong>2. Property Decorators:</strong> Used to modify or observe class properties.</p><ul><li><code>@Input</code> → receive data from parent</li><li><code>@Output</code> → emit events to parent</li><li><code>@ViewChild</code> / <code>@ViewChildren</code> → access child components/elements</li><li><code>@ContentChild</code> / <code>@ContentChildren</code> → access projected content</li></ul></br><p><strong>3. Method Decorators:</strong> Used to modify behavior of methods.</p><ul><li><code>@HostListener</code> → listens to DOM events on host</li><li><code>@HostBinding</code> → bind host element properties</li></ul></br><p><strong>4. Parameter Decorators:</strong> Used to read or modify constructor parameters, mainly for DI.</p><ul><li><code>@Inject()</code> → manually inject dependencies</li><li><code>@Optional()</code> → optional dependency</li></ul></br><p><strong>Notes:</strong></p><ul><li><strong>Metadata</strong> = extra information about a class, method, or property — which helps Angular or TypeScript understand <strong>how to treat it</strong>.</li><li><strong>Behavior</strong> = extra functionality added by the decorator.</li></ul>",
                        "subjectId": 8,
                        "sectionId": 101,
                        "subSectionId": 130,
                        "contentId": 209,
                        "text": "<p><strong>Decorators in TypeScript (how Angular uses them).</strong></p>"
                    }
                ],
                "subSections": []
            },
            {
                "name": "<p><strong>Tuple</strong></p>",
                "sectionId": 101,
                "subSectionId": 131,
                "subjectId": 8,
                "contents": [
                    {
                        "description": "<p>Tuple types in TypeScript allow you to <strong>define an array with a fixed number of elements where each element has a specific type</strong>.</p></br><pre data-language=\"plain\">\nlet person: [string, number] = [&quot;Vivek&quot;, 31];\n</pre></br>",
                        "subjectId": 8,
                        "sectionId": 101,
                        "subSectionId": 131,
                        "contentId": 210,
                        "text": "<p><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">What are </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">tuple types</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">?</span></p>"
                    }
                ],
                "subSections": []
            },
            {
                "name": "<p><strong>Enums</strong></p>",
                "sectionId": 101,
                "subSectionId": 132,
                "subjectId": 8,
                "contents": [
                    {
                        "description": "<p>Enums in TypeScript are a special type that allow you to define a <strong>set of named constant values</strong>. They help make code more <strong>readable, maintainable, and type-safe</strong>, especially when working with a known set of options.</p>",
                        "subjectId": 8,
                        "sectionId": 101,
                        "subSectionId": 132,
                        "contentId": 211,
                        "text": "<p><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">What are </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">Enums</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\"> and where are they </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">used</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">?</span></p>"
                    }
                ],
                "subSections": []
            }
        ]
    },
    {
        "name": "<p><strong>Extends and Implements</strong></p>",
        "sectionId": 133,
        "subSectionId": -1,
        "subjectId": 8,
        "contents": [],
        "subSections": [
            {
                "name": "<p><strong>Extends and Implements</strong></p>",
                "sectionId": 133,
                "subSectionId": 134,
                "subjectId": 8,
                "contents": [
                    {
                        "text": "<p>In <strong>TypeScript</strong>, we use <code>extends</code> and <code>implements</code>. What is the difference between them?</p>",
                        "sectionId": 133,
                        "subSectionId": 134,
                        "subjectId": 8,
                        "contentId": 422,
                        "description": "<p><code>extends</code> is used for <strong>class inheritance</strong> — it copies properties and methods.</p><p><code>implements</code> is used to enforce that a <strong>class </strong>follows an <strong>interface </strong>— it provides no implementation.</p><p>Use <code>extends</code> for code reuse, <code>implements</code> for structure enforcement.</p></br><p><strong>1. </strong><code><strong>extends</strong></code><strong> → Inheritance (Reusing Implementation):</strong></p><pre data-language=\"plain\">\nclass Animal {\n  move() {\n    console.log(&quot;Moving&quot;);\n  }\n}\n\nclass Dog extends Animal {\n  bark() {\n    console.log(&quot;Bark!&quot;);\n  }\n}\n</pre></br></br><p><strong>2. implements → Contract Checking (Structure Only)</strong></p><pre data-language=\"plain\">\ninterface Drivable {\n  start(): void;\n  stop(): void;\n}\n\nclass Car implements Drivable {\n  start() {}\n  stop() {}\n}\n</pre>"
                    }
                ],
                "subSections": []
            }
        ]
    }
]