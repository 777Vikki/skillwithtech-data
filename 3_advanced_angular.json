[
    {
        "name": "<p><strong>Tokens, Restfull API and HTTP, Soket, SDLC and Project Methodology, CORS</strong></p>",
        "subjectId": 3,
        "sectionId": 35,
        "subSectionId": -1,
        "subSections": [
            {
                "name": "<p><strong>Tokens</strong></p>",
                "subjectId": 3,
                "sectionId": 35,
                "subSectionId": 36,
                "subSections": [],
                "contents": [
                    {
                        "description": "<p><strong>Authorization Tokens: </strong></p><p>Authorization tokens are <strong>pieces of data (usually a string)</strong> issued by the server that prove a user is <strong>authenticated</strong> and has permission to access certain resources.</p></br><p><strong>Common Types:</strong></p><ol><li><strong>JWT (JSON Web Token)</strong> ‚Äì Encodes user info and expiry time.</li><li><strong>OAuth Tokens</strong> ‚Äì Access tokens issued by OAuth providers.</li><li><strong>Custom tokens</strong> ‚Äì Sometimes generated by your backend.</li></ol></br>",
                        "subjectId": 3,
                        "sectionId": 35,
                        "subSectionId": 36,
                        "contentId": 95,
                        "text": "<p>What are authorization tokens in angular?</p>"
                    },
                    {
                        "description": "<p>A <strong>Bearer Token</strong> is used for <strong>authorization</strong>, while a <strong>JWT token</strong> can be used for both <strong>authorization</strong> and carrying <strong>user data/claims</strong>.</p>",
                        "subjectId": 3,
                        "sectionId": 35,
                        "subSectionId": 36,
                        "contentId": 96,
                        "text": "<p>Do you have any idea about bearer token and JWT token?</p>"
                    }
                ]
            },
            {
                "name": "<p><strong>Restful API and HTTP</strong></p>",
                "subjectId": 3,
                "sectionId": 35,
                "subSectionId": 37,
                "subSections": [],
                "contents": [
                    {
                        "description": "<p>A <strong>REST API</strong> (Representational State Transfer Application Programming Interface) is a way for two systems (such as a <strong>frontend app</strong> and a <strong>backend server</strong>) to communicate over the Internet using standard <strong>HTTP methods</strong>.</p></br><p><strong>Common HTTP methods:</strong></p><ul><li><strong>GET</strong> ‚Üí Retrieve data</li><li><strong>POST</strong> ‚Üí Create new data</li><li><strong>PUT / PATCH</strong> ‚Üí Update existing data</li><li><strong>DELETE</strong> ‚Üí Remove data</li></ul></br>",
                        "subjectId": 3,
                        "sectionId": 35,
                        "subSectionId": 37,
                        "contentId": 97,
                        "text": "<p>What is a Restful API?</p>"
                    },
                    {
                        "description": "<p><strong>HTTP Status Codes</strong> are <strong>three-digit numbers</strong> returned by a <strong>server</strong> in response to a <strong>client‚Äôs request.</strong></p></br><p><strong>Most Common HTTP Status Codes:</strong></p><table style=\"border: 1px solid #000;\"><tbody><tr><td data-row=\"2\"><strong>200 OK</strong></td><td data-row=\"2\">Success</td><td data-row=\"2\">Request completed successfully</td></tr><tr><td data-row=\"3\"><strong>201 Created</strong></td><td data-row=\"3\">Resource Created</td><td data-row=\"3\">New record created (e.g., signup, post creation)</td></tr><tr><td data-row=\"4\"><strong>204 No Content</strong></td><td data-row=\"4\">Success without data</td><td data-row=\"4\">Request successful, no body returned</td></tr><tr><td data-row=\"5\"><strong>301 Moved Permanently</strong></td><td data-row=\"5\">Redirect</td><td data-row=\"5\">URL changed permanently</td></tr><tr><td data-row=\"6\"><strong>400 Bad Request</strong></td><td data-row=\"6\">Invalid Input</td><td data-row=\"6\">Request format or data is wrong</td></tr><tr><td data-row=\"7\"><strong>401 Unauthorized</strong></td><td data-row=\"7\">Authentication Failed</td><td data-row=\"7\">Token missing/invalid</td></tr><tr><td data-row=\"8\"><strong>403 Forbidden</strong></td><td data-row=\"8\">Access Denied</td><td data-row=\"8\">You‚Äôre authenticated but not allowed</td></tr><tr><td data-row=\"9\"><strong>404 Not Found</strong></td><td data-row=\"9\">Resource Missing</td><td data-row=\"9\">Endpoint or data not found</td></tr><tr><td data-row=\"10\"><strong>409 Conflict</strong></td><td data-row=\"10\">Duplicate data</td><td data-row=\"10\">Same record already exists</td></tr><tr><td data-row=\"11\"><strong>500 Internal Server Error</strong></td><td data-row=\"11\">Server crashed</td><td data-row=\"11\">Code exception or backend failure</td></tr><tr><td data-row=\"12\"><strong>502 Bad Gateway</strong></td><td data-row=\"12\">Gateway problem</td><td data-row=\"12\">Reverse proxy/server issue</td></tr><tr><td data-row=\"13\"><strong>503 Service Unavailable</strong></td><td data-row=\"13\">Server Down</td><td data-row=\"13\">Maintenance or overload</td></tr><tr><td data-row=\"14\"><strong>504 Gateway Timeout</strong></td><td data-row=\"14\">Timeout</td><td data-row=\"14\">Server didn‚Äôt respond in time</td></tr></tbody></table></br>",
                        "subjectId": 3,
                        "sectionId": 35,
                        "subSectionId": 37,
                        "contentId": 98,
                        "text": "<p>What are HTTP Status Codes?</p>"
                    },
                    {
                        "description": "<p>4xx = client-side issue (your request), 5xx = server-side issue.</p>",
                        "subjectId": 3,
                        "sectionId": 35,
                        "subSectionId": 37,
                        "contentId": 99,
                        "text": "<p>What is the difference between 4xx and 5xx?</p>"
                    },
                    {
                        "description": "<p>401 = not logged in or token invalid.</p></br><p>403 = logged in but access denied.</p>",
                        "subjectId": 3,
                        "sectionId": 35,
                        "subSectionId": 37,
                        "contentId": 100,
                        "text": "<p>What happens when you get 401 or 403?</p>"
                    }
                ]
            },
            {
                "name": "<p><strong>Socket</strong></p>",
                "subjectId": 3,
                "sectionId": 35,
                "subSectionId": 38,
                "subSections": [],
                "contents": [
                    {
                        "description": "<p>A socket is a persistent connection between a client and server that allows real-time, two-way communication.</p><p>In Angular, we can use WebSocket or Socket.IO to send and receive messages instantly without refreshing the page, which is useful for chat apps, notifications, or live updates.</p></br><p><strong>install socket.io</strong></p><pre data-language=\"plain\">\nnpm install socket.io-client\n</pre></br><pre data-language=\"plain\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport { io, Socket } from &#39;socket.io-client&#39;;\nimport { Observable } from &#39;rxjs&#39;;\n\n@Injectable({ providedIn: &#39;root&#39; })\nexport class SocketService {\n  private socket: Socket;\n\n  constructor() {\n    this.socket = io(&#39;http://localhost:3000&#39;); // backend server\n  }\n\n  // Send message to server\n  sendMessage(msg: string) {\n    this.socket.emit(&#39;message&#39;, msg);\n  }\n\n  // Receive message from server\n  onMessage(): Observable&lt;string&gt; {\n    return new Observable(observer =&gt; {\n      this.socket.on(&#39;message&#39;, (data: string) =&gt; observer.next(data));\n    });\n  }\n}\n</pre>",
                        "subjectId": 3,
                        "sectionId": 35,
                        "subSectionId": 38,
                        "contentId": 101,
                        "text": "<p>What is Socket?</p>"
                    }
                ]
            },
            {
                "name": "<p><strong>SDLC (Software Development Life Cycle) and project methodology</strong></p>",
                "subjectId": 3,
                "sectionId": 35,
                "subSectionId": 39,
                "subSections": [],
                "contents": [
                    {
                        "description": "<p>In our project, we follow the <strong>Agile model</strong>, specifically the <strong>Scrum process</strong>.</p><p>Our development is divided into <strong>sprints</strong>, usually of <strong>two weeks</strong>.</p></br><p>At the beginning of each sprint, we conduct a <strong>Sprint Planning Meeting</strong> to discuss and finalize the features or tasks to be developed.</p></br><p>Every day, we have a <strong>daily stand-up meeting</strong> where each team member shares their progress, challenges, and plans for the day.</p></br><p>Once the sprint ends, we conduct a <strong>Sprint Review</strong> to demonstrate the completed work to stakeholders and get feedback.</p><p>Then, we have a <strong>Sprint Retrospective</strong> to identify what went well, what didn‚Äôt, and how we can improve in the next sprint.</p></br><p>This process helps us deliver features incrementally, respond quickly to changes in requirements, and maintain good collaboration between developers, testers, and product owners.</p>",
                        "subjectId": 3,
                        "sectionId": 35,
                        "subSectionId": 39,
                        "contentId": 102,
                        "text": "<p>Which model or process is followed in your project?</p>"
                    },
                    {
                        "description": "<p>The <strong>Agile Model</strong> is a <strong>software development approach</strong> where the project is divided into <strong>small parts called sprints or iterations</strong>, and each sprint delivers a <strong>working piece of the product</strong>.</p><p>It focuses on <strong>continuous feedback, flexibility, and fast delivery</strong> instead of completing everything at once like the traditional Waterfall model.</p>",
                        "subjectId": 3,
                        "sectionId": 35,
                        "subSectionId": 39,
                        "contentId": 103,
                        "text": "<p>What is Agile Model?</p>"
                    },
                    {
                        "description": "<p><strong>CI/CD</strong> stands for <strong>Continuous Integration</strong> and <strong>Continuous Delivery (or Deployment)</strong>.</p><p>It is a <strong>DevOps practice</strong> that automates the process of building, testing, and deploying code to ensure faster and more reliable software delivery.</p>",
                        "subjectId": 3,
                        "sectionId": 35,
                        "subSectionId": 39,
                        "contentId": 104,
                        "text": "<p>What is CI/CD Model?</p>"
                    },
                    {
                        "description": "<p><strong>DevOps</strong> is a combination of <strong>Development (Dev)</strong> and <strong>Operations (Ops)</strong>.</p><p>It is a <strong>culture and set of practices</strong> that brings <strong>developers and operations teams together</strong> to build, test, and release software <strong>faster, more reliably, and with better collaboration</strong>.</p>",
                        "subjectId": 3,
                        "sectionId": 35,
                        "subSectionId": 39,
                        "contentId": 105,
                        "text": "<p>What is DevOps?</p>"
                    },
                    {
                        "description": "<p>The <strong>SOLID Principles</strong> are <strong>five key design principles</strong> in <strong>object-oriented programming (OOP)</strong> that help you write <strong>clean, maintainable, and scalable code</strong>.</p></br><p>They are especially useful in frameworks like Angular, React, or backend systems (Java, Node.js, etc.) when you design services, classes, or components.</p></br><table style=\"border: 1px solid #000;\"><tbody><tr><td data-row=\"1\">Letter Principle Purpose</td></tr><tr><td data-row=\"2\"><strong>S</strong></td><td data-row=\"2\"><strong>Single Responsibility Principle (SRP)</strong></td><td data-row=\"2\">A class should have <strong>only one reason to change</strong> ‚Äî i.e., one responsibility.</td></tr><tr><td data-row=\"3\"><strong>O</strong></td><td data-row=\"3\"><strong>Open/Closed Principle (OCP)</strong></td><td data-row=\"3\">Classes should be <strong>open for extension</strong>, but <strong>closed for modification</strong>.</td></tr><tr><td data-row=\"4\"><strong>L</strong></td><td data-row=\"4\"><strong>Liskov Substitution Principle (LSP)</strong></td><td data-row=\"4\">Subclasses should be <strong>replaceable</strong> with their base classes <strong>without breaking functionality</strong>.</td></tr><tr><td data-row=\"5\"><strong>I</strong></td><td data-row=\"5\"><strong>Interface Segregation Principle (ISP)</strong></td><td data-row=\"5\">Don‚Äôt force a class to implement <strong>interfaces it doesn‚Äôt use</strong>.</td></tr><tr><td data-row=\"6\"><strong>D</strong></td><td data-row=\"6\"><strong>Dependency Inversion Principle (DIP)</strong></td><td data-row=\"6\">Depend on <strong>abstractions</strong>, not <strong>concrete implementations</strong>.</td></tr></tbody></table></br>",
                        "subjectId": 3,
                        "sectionId": 35,
                        "subSectionId": 39,
                        "contentId": 106,
                        "text": "<p>What is Solid Principle?</p>"
                    }
                ]
            },
            {
                "name": "<p><strong>CORS (Cross-Origin Resource Sharing)</strong></p>",
                "subjectId": 3,
                "sectionId": 35,
                "subSectionId": 40,
                "subSections": [],
                "contents": [
                    {
                        "description": "<p>CORS is a browser security mechanism that blocks frontend apps from making requests to a different origin unless the server explicitly allows it via <code>Access-Control-Allow-Origin</code> headers. In Angular, we face CORS errors when the frontend and backend have different origins. The correct solution is to configure the backend to allow requests from the Angular app‚Äôs origin and, if cookies are used, enable <code>credentials: true</code>.</p>",
                        "subjectId": 3,
                        "sectionId": 35,
                        "subSectionId": 40,
                        "contentId": 107,
                        "text": "<p><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">What is CORS (Cross-Origin Resource Sharing)</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">, and why do we face </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">CORS errors</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\"> in Angular applications?</span></p>"
                    }
                ]
            }
        ],
        "contents": []
    },
    {
        "name": "<p><strong>Application&#39;s Architecture, Error Handling and State Management</strong></p>",
        "sectionId": 96,
        "subSectionId": -1,
        "subjectId": 3,
        "contents": [],
        "subSections": [
            {
                "name": "<p><strong>Angular Application Architecture</strong></p>",
                "sectionId": 96,
                "subSectionId": 102,
                "subjectId": 3,
                "contents": [
                    {
                        "text": "<p>Can you explain the <strong>architecture </strong>of your <strong>Angular application</strong>?</p>",
                        "sectionId": 96,
                        "subSectionId": 102,
                        "subjectId": 3,
                        "contentId": 363,
                        "description": "<p>In my <strong>Angular projects</strong>, I follow a combination of <strong>architectural </strong>and <strong>design patterns</strong> that help ensure <strong>scalability</strong>, <strong>maintainability</strong>, and <strong>clean separation</strong> of concerns.</p></br><p>I primarily use <strong>Component-based architecture</strong> along with <strong>Smart‚ÄìDumb component</strong> separation to keep <strong>UI </strong>and<strong> logic decoupled</strong>.</p></br><p>For state isolation and cleaner APIs, I use the <strong>Facade pattern</strong>.</p></br><p>Shared logic is placed in <strong>Singleton services </strong>using <strong>Angular‚Äôs dependency injection system</strong>.</p></br><p>I follow<strong> reactive programming principles</strong> using<strong> RxJS Observables</strong>, and for <strong>complex state</strong>, I use the <strong>NgRx Store pattern</strong> <strong>(actions, reducers, selectors, effects)</strong>.</p></br><p>Together, these patterns help me deliver <strong>scalable</strong>, <strong>predictable</strong>, and easily <strong>testable Angular applications</strong>.</p>"
                    }
                ],
                "subSections": []
            },
            {
                "name": "<p><strong>Error Handling</strong></p>",
                "sectionId": 96,
                "subSectionId": 97,
                "subjectId": 3,
                "contents": [
                    {
                        "text": "<p>How to Handle Errors in Angular?</p>",
                        "sectionId": 96,
                        "subSectionId": 97,
                        "subjectId": 3,
                        "contentId": 359,
                        "description": "<p>In Angular, error handling happens at multiple layers:</p><p><strong>1. Global API errors</strong> are handled in an <code>HttpInterceptor</code> using the RxJS <code>catchError</code> operator.</p><pre data-language=\"plain\">\n@Injectable()\nexport class ErrorInterceptor implements HttpInterceptor {\n  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {\n    return next.handle(req).pipe(\n      catchError((error: HttpErrorResponse) =&gt; {\n        let message = &#39;&#39;;\n\n        if (error.status === 0) {\n          message = &#39;Network error&#39;;\n        } else if (error.status === 401) {\n          message = &#39;Unauthorized&#39;;\n        } else if (error.status === 500) {\n          message = &#39;Server Error&#39;;\n        } else {\n          message = error.error?.message || &#39;Something went wrong&#39;;\n        }\n\n        // Optional: Show toast\n        // this.toastr.error(message);\n\n        return throwError(() =&gt; new Error(message));\n      })\n    );\n  }\n}\n</pre></br><p><strong>2.</strong> I use <code>catchError</code> inside service methods when a specific API requires custom error handling.</p><p><strong>3.</strong> I use the <strong>Optional Chaining Operator (</strong><code><strong>?.</strong></code><strong>)</strong> in templates to safely handle <code>null</code> or <code>undefined</code> values.</p></br><pre data-language=\"plain\">\n&lt;p&gt;{{ user?.name }}&lt;/p&gt;\n</pre></br><p><strong>4.</strong> I use <code><strong>retry</strong></code> and <code><strong>retryWhen</strong></code> for API retry logic when dealing with unstable network calls.</p></br><p><code>retry</code> is an RxJS operator that <strong>automatically retries a failed observable (such as an HTTP call) a specified number of times</strong> before throwing an error.</p><pre data-language=\"plain\">\nthis.http.get(url).pipe(\n  retry(3),     // tries 3 times if the request fails\n  catchError(err =&gt; throwError(() =&gt; err))\n);\n</pre></br><p><code>retryWhen</code> is an advanced operator used when you need <strong>custom retry logic</strong>.</p><p>You can add <strong>delay</strong>, <strong>exponential backoff</strong>, <strong>conditions</strong>, etc.</p><pre data-language=\"plain\">\nthis.http.get(url).pipe(\n  retryWhen(errors =&gt;\n    errors.pipe(\n      delay(2000),   // wait 2 seconds before retrying\n      take(3),       // retry 3 times\n      catchError(err =&gt; throwError(() =&gt; err))\n    )\n  )\n);\n</pre>"
                    }
                ],
                "subSections": []
            },
            {
                "name": "<p><strong>State Management</strong></p>",
                "sectionId": 96,
                "subSectionId": 98,
                "subjectId": 3,
                "contents": [
                    {
                        "text": "<p>How can we manage <strong>state </strong>in <strong>Angular</strong>?</p>",
                        "sectionId": 96,
                        "subSectionId": 98,
                        "subjectId": 3,
                        "contentId": 360,
                        "description": "<p>We manage <strong>state </strong>in <strong>Angular </strong>depending on the complexity of the application.</p><p>For simple local component state, I use <code>component variables</code>  and  <code>@Input/Output</code> .</p><p>For shared state, I use services with <strong>RxJS </strong><code>BehaviorSubject</code> or <code>ReplaySubject</code>.</p><p>For large enterprise applications, I prefer using <strong>NgRx </strong>because it provides a predictable <strong>store</strong>, <strong>immutability, actions, reducers, effects</strong>, and <strong>selectors</strong>. Angular also supports signals for lightweight <strong>reactive state</strong>.</p>"
                    }
                ],
                "subSections": []
            }
        ]
    },
    {
        "name": "<p><strong>SSR,</strong> <strong>Caching, Webpack, Store Token and Secure</strong></p>",
        "subjectId": 3,
        "sectionId": 42,
        "subSectionId": -1,
        "subSections": [
            {
                "name": "<p><strong>SSR</strong></p>",
                "sectionId": 42,
                "subSectionId": 100,
                "subjectId": 3,
                "contents": [
                    {
                        "text": "<p><strong style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\">What is SSR (Server-Side Rendering)</strong><span style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\">, and why is it used in Angular?</span></p>",
                        "sectionId": 42,
                        "subSectionId": 100,
                        "subjectId": 3,
                        "contentId": 361,
                        "description": "<p>SSR (Server-Side Rendering) means <strong>Angular renders the initial HTML of the application on the server instead of the browser</strong>.</p><p>Normally, Angular apps load a blank HTML and then bootstrap JavaScript.</p><p>With SSR, the server sends <strong>fully rendered HTML</strong>, and then Angular takes over on the browser.</p></br><p><strong>Add SSR to your app:</strong></p><pre data-language=\"plain\">\nng add @angular/ssr\n</pre></br><p>Angular will:</p><ul><li>Convert your app to SSR setup</li><li>Create <code>server.ts</code></li><li>Create a server build</li><li>Enable hydration automatically</li></ul></br>"
                    }
                ],
                "subSections": []
            },
            {
                "name": "<p><strong>Caching</strong></p>",
                "subjectId": 3,
                "sectionId": 42,
                "subSectionId": 43,
                "subSections": [],
                "contents": [
                    {
                        "description": "<p><strong>Caching</strong> is the process of storing data temporarily so that future requests can be served faster without fetching data again from the server.</p></br><pre data-language=\"plain\">\n@Injectable({ providedIn: &#39;root&#39; })\nexport class DataService {\n  private cache = new Map&lt;string, any&gt;();\n\n  constructor(private http: HttpClient) {}\n\n  getData(url: string): Observable&lt;any&gt; {\n    if (this.cache.has(url)) {\n      // Return cached data\n      return of(this.cache.get(url));\n    } else {\n      return this.http.get(url).pipe(\n        tap(data =&gt; this.cache.set(url, data))\n      );\n    }\n  }\n}\n</pre></br>",
                        "subjectId": 3,
                        "sectionId": 42,
                        "subSectionId": 43,
                        "contentId": 110,
                        "text": "<p><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">What is </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">caching</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">, and how do you implement </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">caching</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\"> in Angular?</span></p>"
                    }
                ]
            },
            {
                "name": "<p><strong>Webpack</strong></p>",
                "subjectId": 3,
                "sectionId": 42,
                "subSectionId": 44,
                "subSections": [],
                "contents": [
                    {
                        "description": "<p><strong>Webpack</strong> is a <strong>module bundler</strong> ‚Äî it takes all the files and dependencies in your Angular project (like TypeScript, HTML, SCSS, images, etc.) and bundles them into optimized JavaScript files that the browser can understand and load efficiently.</p></br><p><strong>How Webpack is used in Angular:</strong></p><p>Angular uses Webpack <strong>under the hood</strong> through the <strong>Angular CLI</strong>.</p><p>You don‚Äôt manually configure Webpack ‚Äî it‚Äôs already integrated and managed internally by Angular CLI (<code>@angular/cli</code>).</p><p>When you run Angular CLI commands, Webpack is working behind the scenes:</p><table style=\"border: 1px solid #000;\"><tbody><tr><td data-row=\"1\"></td></tr><tr><td data-row=\"2\"><code>ng serve</code></td><td data-row=\"2\">Starts a <strong>Webpack Dev Server</strong> for live reloading during development.</td></tr><tr><td data-row=\"3\"><code>ng build</code></td><td data-row=\"3\">Uses Webpack to bundle and optimize code (tree-shaking, minification, lazy loading).</td></tr><tr><td data-row=\"4\"><code>ng test</code></td><td data-row=\"4\">Webpack bundles test files before running them.</td></tr></tbody></table></br>",
                        "subjectId": 3,
                        "sectionId": 42,
                        "subSectionId": 44,
                        "contentId": 111,
                        "text": "<p><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">What is Webpack</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">, and how is it used in </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">Angular</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">?</span></p>"
                    }
                ]
            },
            {
                "name": "<p><strong>Store Token</strong></p>",
                "subjectId": 3,
                "sectionId": 42,
                "subSectionId": 45,
                "subSections": [],
                "contents": [
                    {
                        "description": "<p>The best way to store the authentication token in Angular is in an <strong>HttpOnly Secure Cookie</strong>, which is safe from JavaScript access and XSS attacks.</p><p>For less critical apps, it can be stored in memory during the session.</p><p>Storing tokens in localStorage or sessionStorage is not recommended because they can be accessed by malicious scripts.</p></br><p>Angular <strong>does not need to attach the token manually</strong>. Cookies are automatically sent with requests <strong>if </strong><code><strong>withCredentials</strong></code><strong> is true</strong>:</p><pre data-language=\"plain\">\nthis.http.get(&#39;/api/profile&#39;, { withCredentials: true }).subscribe(\n  data =&gt; console.log(data)\n);\n</pre></br><p>Backend clears the cookie:</p><pre data-language=\"plain\">\napp.post(&#39;/logout&#39;, (req, res) =&gt; {\n  res.clearCookie(&#39;authToken&#39;);\n  res.json({ message: &#39;Logged out&#39; });\n});\n</pre>",
                        "subjectId": 3,
                        "sectionId": 42,
                        "subSectionId": 45,
                        "contentId": 112,
                        "text": "<p><span style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\">Where should we store token in angular?</span></p>"
                    }
                ]
            },
            {
                "name": "<p><strong>Secure</strong></p>",
                "sectionId": 42,
                "subSectionId": 111,
                "subjectId": 3,
                "contents": [
                    {
                        "text": "<p>How can we secure Angular Application?</p>",
                        "sectionId": 42,
                        "subSectionId": 111,
                        "subjectId": 3,
                        "contentId": 397,
                        "description": "<p>I secure an Angular app using guards, secure cookie-based authentication, interceptors, XSS prevention, HTTPS with security headers, CSRF protection, and proper production builds ‚Äî keeping all sensitive logic in the backend.</p></br><p><strong>secure cookie-based authentication:</strong></p><p>When I send the login API request with <code>{ withCredentials: true }</code>, the backend sends a cookie to the browser. After that, for every API request made with <code>{ withCredentials: true }</code>, the browser automatically sends the cookie back to the backend for authentication.</p></br><p><strong>Interceptors:</strong></p><p>Angular HTTP interceptors are used to automatically attach authentication credentials to API requests.</p><pre data-language=\"plain\">\nreq = req.clone({\n  withCredentials: true,\n  setHeaders: {\n    Authorization: `Bearer ${token}`\n  }\n});\n</pre></br><p><strong>XSS prevention:</strong></p><p>We can secure an Angular application against XSS (Cross-Site Scripting) attacks. When inserting HTML dynamically using <code>innerHTML</code>, we must sanitize it using <code>this.sanitizer.bypassSecurityTrustHtml(userInput)</code>.</p><pre data-language=\"plain\">\nimport { DomSanitizer, SafeHtml } from &#39;@angular/platform-browser&#39;;\n\nconstructor(private sanitizer: DomSanitizer) {}\n\nsafeHtml: SafeHtml;\n\nngOnInit() {\n  this.safeHtml = this.sanitizer.bypassSecurityTrustHtml(userInput);\n}\n\n</pre></br>"
                    }
                ],
                "subSections": []
            }
        ],
        "contents": []
    },
    {
        "name": "<p><strong>Tree shaking, Minification, Uglification</strong></p>",
        "sectionId": 103,
        "subSectionId": -1,
        "subjectId": 3,
        "contents": [
            {
                "text": "<p>Tree Shaking</p>",
                "sectionId": 103,
                "subSectionId": -1,
                "subjectId": 3,
                "contentId": 364,
                "description": "<p><strong>Tree shaking</strong> is the process of removing unused code from the final <strong>bundle </strong>so that only the parts of the application actually used remain.</p>"
            },
            {
                "text": "<p>Minification</p>",
                "sectionId": 103,
                "subSectionId": -1,
                "subjectId": 3,
                "contentId": 365,
                "description": "<p><strong>Minification </strong>removes <strong>whitespace</strong>, <strong>comments</strong>, <strong>line breaks</strong>, and <strong>shortens variable </strong>names to make the code smaller and faster to download.</p>"
            },
            {
                "text": "<p>Uglification (uglifying)</p>",
                "sectionId": 103,
                "subSectionId": -1,
                "subjectId": 3,
                "contentId": 366,
                "description": "<p><strong>Uglification </strong>is the process of rewriting code into an <strong>unreadable</strong>, condensed format by shortening variable names, removing structure, and compressing code to reduce file size.</p></br><p><strong>Before Uglification</strong></p><pre data-language=\"plain\">\nfunction calculateTotal(price, tax) {\n  let total = price + tax;\n  return total;\n}\n</pre></br><p><strong>After Uglification</strong></p><pre data-language=\"plain\">\nfunction a(b,c){return b+c}\n</pre>"
            }
        ],
        "subSections": []
    },
    {
        "name": "<p><strong>Performance Optimization</strong></p>",
        "sectionId": 88,
        "subSectionId": -1,
        "subjectId": 3,
        "contents": [],
        "subSections": [
            {
                "name": "<p><strong>Performance Optimization</strong></p>",
                "sectionId": 88,
                "subSectionId": 123,
                "subjectId": 3,
                "contents": [
                    {
                        "text": "<p>How can you optimize Angular Application for better performance?</p>",
                        "sectionId": 88,
                        "subSectionId": 123,
                        "subjectId": 3,
                        "contentId": 340,
                        "description": "<p>In Angular, I optimize <strong>performance</strong> by using <strong>OnPush change detection</strong> with <strong>immutable data</strong>, <strong>trackBy</strong> in <strong>ngFor</strong> to avoid re-rendering, and <strong>pure pipes</strong> for efficiency. I also <strong>lazy load</strong> modules or components to reduce <strong>bundle size</strong>, move <strong>heavy logic</strong> out of <strong>templates</strong>, and <strong>unsubscribe</strong> from <strong>observables</strong> to prevent <strong>memory leaks</strong>. Additionally, I use <strong>standalone components</strong> and <strong>preloading strategies</strong> to improve <strong>load time</strong>.</p></br><p><strong>Immutable Data: </strong></p><p>If a component uses the <strong>OnPush change detection strategy</strong>, it <strong>won‚Äôt detect changes</strong> to an <code>@Input()</code> property <strong>unless the input‚Äôs reference changes</strong>.</p></br><pre data-language=\"plain\">\n// ‚ùå Mutable (Angular won&#39;t detect inside change with OnPush)\nthis.user.name = &quot;Alice&quot;;  \n\n// ‚úÖ Immutable (Angular detects new reference)\nthis.user = { ...this.user, name: &quot;Alice&quot; };\n</pre></br></br><p><strong>move heavy logic out of templates:</strong></p><p>If we call functions from the template for <code>*ngFor</code> or <code>*ngIf</code>, these functions are executed on every change detection cycle, whether the data has changed or not, which makes the performance slow.</p></br><pre data-language=\"plain\">\n‚ùå Bad Practice (heavy logic in template):\n\n&lt;div *ngFor=&quot;let user of getActiveUsers()&quot;&gt;\n  {{ calculateAge(user.dob) }}\n&lt;/div&gt;\n</pre></br>"
                    },
                    {
                        "text": "<p>If on a button click I hit an API and the API takes 2 minutes and I keep clicking the button then when I get a response how can I cancel all the other API calls?</p>",
                        "sectionId": 88,
                        "subSectionId": 123,
                        "subjectId": 3,
                        "contentId": 341,
                        "description": "<p>We can use RxJS operator <strong>race</strong>, in which all observables execute simultaneously. If any one observable <strong>emits first (either value or completion)</strong>, all the other observables will be canceled or unsubscribed.</p></br><pre data-language=\"plain\">\nimport { Component } from &#39;@angular/core&#39;;\nimport { HttpClient } from &#39;@angular/common/http&#39;;\nimport { race, Observable } from &#39;rxjs&#39;;\n\n@Component({\n  selector: &#39;app-api-race&#39;,\n  template: `&lt;button (click)=&quot;callApis()&quot;&gt;Call API&lt;/button&gt;`\n})\nexport class ApiRaceComponent {\n  private apiCalls: Observable&lt;any&gt;[] = [];\n\n  constructor(private http: HttpClient) {}\n\n  callApis() {\n    // Create a new API call on every click\n    const apiCall = this.http.get(&#39;http://localhost:3000/long-api&#39;);\n    this.apiCalls.push(apiCall);\n\n    // Run race on all API calls\n    race(...this.apiCalls).subscribe({\n      next: (res) =&gt; {\n        console.log(&#39;First response wins:&#39;, res);\n        // Cancel all other pending API calls\n        this.apiCalls = [];\n      },\n      error: (err) =&gt; console.log(err)\n    });\n  }\n}\n</pre></br>"
                    }
                ],
                "subSections": []
            },
            {
                "name": "<p><strong>Challenges Faced in Angular Project</strong></p>",
                "subjectId": 3,
                "sectionId": 88,
                "subSectionId": 23,
                "subSections": [],
                "contents": [
                    {
                        "description": "<p>One of the challenges I faced was <strong>implementing a search box</strong>. Initially, every keystroke was hitting the backend API, which <strong>created unnecessary load and poor performance</strong>. I solved this by using <strong>RxJS operators</strong> ‚Äî <code>debounceTime</code> to wait for the user to stop typing, <code>distinctUntilChanged</code> to avoid duplicate searches, and <code>switchMap</code> to cancel previous API calls when a new value was entered. This <strong>optimized API usage</strong> and <strong>improved the user experience</strong>.</p></br><p>Another challenge was <strong>implementing nested drag-and-drop functionality</strong>. The Angular CDK works well for flat lists, but in my project, we needed <strong>hierarchical data movement across multiple levels</strong>. I extended the CDK drag-drop with <strong>custom logic for nested structures</strong> and handled <strong>index recalculations</strong>. This provided <strong>smooth drag-and-drop</strong> for complex data.</p></br><p>I also faced <strong>memory leak issues</strong> due to multiple subscriptions. Some observables were not unsubscribed properly, <strong>leading to performance degradation</strong>. To fix this, I applied the <strong>async pipe</strong> wherever possible, used the <strong>takeUntil pattern with a Subject</strong>, and even created a <strong>BaseComponent</strong> to centralize cleanup logic in <code>ngOnDestroy</code>. This <strong>ensured stability</strong> and <strong>prevented memory leaks</strong>.</p>",
                        "subjectId": 3,
                        "sectionId": 88,
                        "subSectionId": 23,
                        "contentId": 82,
                        "text": "<p>Tell me about some challenges you faced in your Angular projects.</p>"
                    }
                ]
            }
        ]
    },
    {
        "name": "<p><strong>Encapsulation (Emulated, None, ShadowDom), UI and UX, state and state management</strong></p>",
        "sectionId": 112,
        "subSectionId": -1,
        "subjectId": 3,
        "contents": [],
        "subSections": [
            {
                "name": "<p><strong>Encapsulation (Emulated, None, ShadowDom)</strong></p>",
                "sectionId": 112,
                "subSectionId": 113,
                "subjectId": 3,
                "contents": [
                    {
                        "text": "<p>Can you explain Encapsulation?</p>",
                        "sectionId": 112,
                        "subSectionId": 113,
                        "subjectId": 3,
                        "contentId": 399,
                        "description": "<p>ViewEncapsulation in Angular determines how component styles are isolated. Angular supports Emulated (default), ShadowDom, and None to control whether styles apply only inside a component or globally.</p></br><p><strong>ViewEncapsulation.Emulated (Default):</strong></p><p>1. Angular <strong>simulates Shadow DOM</strong> by adding unique attributes to elements.</p><p>2. Component styles are scoped and do not leak outside.</p></br><p><strong>ViewEncapsulation.None:</strong></p><p>1. <strong>No encapsulation</strong> ‚Üí styles behave like normal global CSS.</p><p>2. Styles from the component can <strong>leak to other components</strong>.</p></br><p><strong>ViewEncapsulation.ShadowDom: </strong></p><p>1. Uses the <strong>real browser Shadow DOM</strong>.</p><p>2. Provides <strong>strong style isolation</strong> (stronger than Emulated).</p><p>3. Global styles <strong>cannot enter</strong> the component and vice-versa.</p>"
                    }
                ],
                "subSections": []
            },
            {
                "name": "<p><strong>UI and UX</strong></p>",
                "sectionId": 112,
                "subSectionId": 121,
                "subjectId": 3,
                "contents": [
                    {
                        "text": "<p>What is difference between <strong>UI </strong>and <strong>UX</strong>?</p>",
                        "sectionId": 112,
                        "subSectionId": 121,
                        "subjectId": 3,
                        "contentId": 412,
                        "description": "<p><strong>UI </strong>is about designing the <strong>look </strong>and <strong>feel </strong>of the application ‚Äî the <strong>colors</strong>, <strong>layout</strong>, <strong>typography</strong>, and all <strong>visual elements</strong>. <strong>UX </strong>focuses on how users interact with the product ‚Äî ensuring the flow is <strong>smooth</strong>, <strong>intuitive</strong>, and helps users accomplish tasks easily. Good <strong>UI </strong>attracts users, but good <strong>UX </strong>keeps them engaged.</p>"
                    }
                ],
                "subSections": []
            },
            {
                "name": "<p><strong>State and State Management</strong></p>",
                "sectionId": 112,
                "subSectionId": 122,
                "subjectId": 3,
                "contents": [
                    {
                        "text": "<p>What is <strong>state </strong>and <strong>state management</strong>?</p>",
                        "sectionId": 112,
                        "subSectionId": 122,
                        "subjectId": 3,
                        "contentId": 413,
                        "description": "<p><strong>State</strong> refers to the data or information that your application stores at a given moment and uses to determine how the UI should look or behave.</p></br><p><strong>üîπ Examples of State</strong></p><p><strong>1.</strong> Logged-in user information</p><p><strong>2.</strong> Form inputs</p><p><strong>3.</strong> List of employees retrieved from API</p><p><strong>4.</strong> UI flags (like <code>isLoading</code>, <code>showModal</code>, etc.)</p><p><strong>5.</strong> Cart items in an e-commerce app</p></br><p><strong>State management</strong> is the process of <strong>handling, updating, storing, and synchronizing</strong> this state across different parts of your application.</p><p>It ensures:</p><p><strong>1. </strong>Data remains <strong>consistent</strong></p><p><strong>2.</strong> Multiple components using the same data stay <strong>in sync</strong></p><p><strong>3.</strong> UI updates correctly when the state changes</p><p><strong>4.</strong> Application remains predictable and easier to debug</p>"
                    }
                ],
                "subSections": []
            }
        ]
    }
]