[
    {
        "name": "<p><strong>Basic</strong></p>",
        "subjectId": 2,
        "sectionId": 27,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "",
                "subjectId": 2,
                "sectionId": 27,
                "subSectionId": -1,
                "contentId": 85,
                "text": "<p><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">What </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">new features</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\"> have you used in the </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">latest version of Angular</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">?</span></p>"
            }
        ]
    },
    {
        "name": "<p><strong>Angular 14 Features</strong></p>",
        "subjectId": 2,
        "sectionId": 28,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "<p>Standalone <strong>components</strong> were introduced in <strong>Angular v14+</strong>. A standalone <strong>component</strong> can be defined by setting the flag <code><strong>standalone: true</strong></code> in the <strong>@Component</strong> decorator. These are <strong>self-contained components</strong>, which means any <strong>dependencies</strong> can be imported directly into the <strong>imports</strong> property.</p></br><p>Earlier, Angular used <code><strong>platformBrowserDynamic().bootstrapModule()</strong></code> to load a <strong>module</strong>, and then the <strong>AppComponent</strong> was loaded. In the case of <strong>lazy loading</strong>, Angular used <code><strong>loadChildren</strong></code> to load a <strong>module</strong>, and only then could we access its <strong>components</strong>. If I needed to use a <strong>component</strong> from another <strong>module</strong>, I first had to <strong>import the module</strong> before using the <strong>component</strong>.</p></br><p>With the introduction of <strong>standalone components</strong>, Angular now uses <code><strong>bootstrapApplication()</strong></code> to load the <strong>AppComponent</strong> directly. For <strong>lazy loading</strong>, Angular uses <code><strong>loadComponent()</strong></code> to load a <strong>component</strong> directly. If I need to use a <strong>component</strong> inside another <strong>component</strong>, I can <strong>import that component directly</strong> without needing its <strong>module</strong>. This removes the extra layer of <strong>NgModule</strong>, making <strong>Angular applications</strong> more <strong>lightweight</strong> and <strong>faster</strong>.</p>",
                "subjectId": 2,
                "sectionId": 28,
                "subSectionId": -1,
                "contentId": 86,
                "text": "<p>What are Angular standalone components and how do they differ from NgModules?</p>"
            },
            {
                "description": "<p>In <strong>Angular v14+</strong>, <strong>standalone components</strong> can be <strong>lazy-loaded</strong> directly using <code><strong>loadComponent</strong></code>, without needing to wrap them inside an <strong>NgModule</strong>.</p></br><pre data-language=\"plain\">\nimport { Routes } from &#39;@angular/router&#39;;\n\nconst routes: Routes = [\n  {\n    path: &#39;user&#39;,\n    loadComponent: () =&gt;\n      import(&#39;./user/user.component&#39;).then(m =&gt; m.UserComponent)\n  }\n];\n</pre></br>",
                "subjectId": 2,
                "sectionId": 28,
                "subSectionId": -1,
                "contentId": 87,
                "text": "<p>Can standalone components be lazy-loaded?</p>"
            },
            {
                "text": "<p>Why has <strong>angular </strong>introduced <strong>standalone </strong>component?</p>",
                "sectionId": 28,
                "subSectionId": -1,
                "subjectId": 2,
                "contentId": 426,
                "description": "<p><strong>Angular </strong>introduced standalone components to simplify application <strong>structure</strong>,<strong> </strong>reduce <strong>NgModule</strong> boilerplate, improve<strong> lazy loading </strong>and<strong> tree-shaking</strong>, and align Angular with <strong>modern development patterns</strong>. They make components more <strong>self-contained</strong>, easier to test, and easier to scale, while remaining backward compatible with <strong>NgModules</strong>.</p></br><p><strong>Simpler &amp; Clearer Architecture:</strong></p><p>Hard to track where components were declared and exported.</p></br><p><strong>Align with Modern JavaScript &amp; Angular APIs:</strong></p><p>Angular is moving towards a <strong>functional and modern API design</strong>:</p><ul><li><code>inject()</code></li><li>Functional guards</li><li>Functional interceptors</li><li>Signals</li></ul></br><p><strong>Backward Compatible (Important!)</strong></p><p>NgModules are <strong>not removed</strong></p>"
            }
        ]
    },
    {
        "name": "<p><strong>Angular 15 Features</strong></p>",
        "subjectId": 2,
        "sectionId": 29,
        "subSectionId": -1,
        "subSections": [],
        "contents": []
    },
    {
        "name": "<p><strong>Angular 16 Features</strong></p>",
        "subjectId": 2,
        "sectionId": 30,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "<p><strong>Signals</strong> were introduced in <strong>Angular v16</strong>. A <strong>signal</strong> is a <strong>reactive model</strong> that <strong>stores a value</strong> and <strong>automatically updates the UI</strong> or <strong>triggers components</strong> when the value <strong>changes</strong>.</p></br><p><strong>Signals</strong> are handled using <code><strong>signal()</strong></code>, <code><strong>computed()</strong></code>, and <code><strong>effect()</strong></code>.</p></br><ul><li><code><strong>signal()</strong></code> creates a <strong>reactive value</strong>.</li><li><code><strong>computed()</strong></code> derives <strong>values</strong> based on other <strong>signals</strong>.</li><li><code><strong>effect()</strong></code> runs <strong>side effects</strong> when <strong>signals change</strong>.</li></ul></br><p>A <strong>reactive model</strong> is a way of <strong>managing</strong> and <strong>updating application state automatically</strong> when the <strong>underlying data changes</strong>.</p></br><p>Angular tracks exactly <strong>which parts of the UI</strong> read a <strong>signal</strong>. When the signal <strong>updates</strong>, Angular updates only the <strong>affected DOM parts</strong>, instead of running <strong>change detection</strong> for the <strong>entire component tree</strong>. This removes <strong>unnecessary checks</strong>, reduces <strong>CPU work</strong>, and makes <strong>zone-less Angular</strong> possible.</p>",
                "subjectId": 2,
                "sectionId": 30,
                "subSectionId": -1,
                "contentId": 88,
                "text": "<p>Explain Signals in Angular.</p>"
            },
            {
                "description": "<p><strong>Signals</strong> are <strong>synchronous</strong>, <strong>stateful</strong>, and always hold the <strong>current value</strong>, making them ideal for <strong>local component state</strong> and <strong>fine-grained reactivity</strong>.</p></br><p><strong>Observables</strong> are <strong>asynchronous streams</strong> that can <strong>emit multiple values</strong> over time, suited for handling <strong>async events</strong>, <strong>APIs</strong>, and <strong>complex transformations</strong> using <strong>RxJS operators</strong>.</p>",
                "subjectId": 2,
                "sectionId": 30,
                "subSectionId": -1,
                "contentId": 89,
                "text": "<p>How do they differ from RxJS Observables?</p>"
            },
            {
                "description": "<p><strong>Signals</strong> are great for <strong>local</strong>, <strong>component-level state</strong> and <strong>simple reactive patterns</strong> (e.g., <strong>form states</strong>, <strong>UI toggles</strong>, <strong>derived values</strong>).</p></br><p>Use <strong>NgRx</strong> when the app grows <strong>large</strong>, needs <strong>global consistency</strong>, <strong>scalability</strong>, or <strong>complex side effects</strong>.</p>",
                "subjectId": 2,
                "sectionId": 30,
                "subSectionId": -1,
                "contentId": 90,
                "text": "<p>Can signals replace NgRx? In which scenarios would you still prefer NgRx?</p>"
            },
            {
                "description": "<p><strong>Declarative destroy hooks</strong> are <strong>Angular’s new way</strong> to automatically handle <strong>cleanup</strong> (like <strong>unsubscribing from Observables</strong>) when a <strong>component</strong> or <strong>directive</strong> is <strong>destroyed</strong>, reducing <strong>boilerplate</strong> and avoiding <strong>memory leaks</strong>.</p></br><pre data-language=\"plain\">\nimport { Component, effect, inject, DestroyRef } from &#39;@angular/core&#39;;\nimport { takeUntilDestroyed } from &#39;@angular/core/rxjs-interop&#39;;\n\nconstructor() {\n    // ✅ RxJS cleanup automatically\n    interval(1000)\n      .pipe(takeUntilDestroyed())\n      .subscribe(val =&gt; console.log(&#39;Interval:&#39;, val));\n\n    // ✅ Signals/effect cleanup automatically\n    effect(() =&gt; {\n      console.log(&#39;Effect running&#39;);\n    }, { injector: inject(DestroyRef) });\n}\n</pre></br>",
                "subjectId": 2,
                "sectionId": 30,
                "subSectionId": -1,
                "contentId": 91,
                "text": "<p>What are declarative destroy hooks?</p>"
            }
        ]
    },
    {
        "name": "<p><strong>Angular 17 Features</strong></p>",
        "subjectId": 2,
        "sectionId": 31,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "text": "<p>Key New Features in <strong>Angular 17</strong></p>",
                "sectionId": 31,
                "subSectionId": -1,
                "subjectId": 2,
                "contentId": 428,
                "description": "<p><strong>Angular 17</strong> focuses on <strong>performance</strong>, <strong>developer experience</strong>, and <strong>modernized templates</strong>. It introduces a new built-in <strong>control flow</strong> syntax (<code><strong>@if</strong></code><strong>, </strong><code><strong>@for</strong></code>), <strong>deferrable views </strong>for lazy loading within templates, and improved <strong>SSR </strong>with the new <code><strong>@angular/ssr</strong></code> package. The build system now defaults to<strong> Vite/esbuild</strong> for <strong>faster builds</strong>, and <strong>standalone components</strong> are the default. It also adds new <strong>lifecycle hooks</strong> (<code><strong>afterRender</strong></code><strong>, </strong><code><strong>afterNextRender</strong></code>) and enhances DevTools to inspect <strong>dependency injection</strong>. Together, these make Angular apps <strong>faster</strong>, <strong>easier </strong>to debug, and simpler to <strong>structure</strong>.</p>"
            },
            {
                "description": "<p>Angular 17 introduces a <strong>new declarative control-flow syntax</strong> (<code><strong>@if</strong></code><strong>, </strong><code><strong>@for</strong></code><strong>, </strong><code><strong>@switch</strong></code>, etc.) that replaces traditional structural directives like <code><strong>*ngIf</strong></code><strong>, </strong><code><strong>*ngFor</strong></code>, and <code><strong>*ngSwitch</strong></code>.</p></br><p>Built-in <strong>control flow</strong> is compiled directly by <strong>Angular</strong>, so it avoids <strong>directive </strong>overhead and improves <strong>runtime performance</strong>.</p>",
                "subjectId": 2,
                "sectionId": 31,
                "subSectionId": -1,
                "contentId": 92,
                "text": "<p>What is new Built-In <strong>Control Flow</strong> Syntax</p>"
            },
            {
                "description": "<p>Deferrable Views are also known as <code><strong>@defer</strong></code><strong> blocks</strong>, and this is a powerful tool that can be used to reduce the initial bundle size of an Angular application.</p></br><p>We can use the Deferrable View concept if we want to load any content or a block of a component based on a specific condition or event.</p></br><p>A defer block wraps the component inside an <code>@defer</code> block to load it as a separate chunk, and by default, the defer block is triggered when the browser state becomes idle.</p></br><p>The <code>@placeholder</code>, <code>@loading</code>, and <code>@error</code> blocks are optional and help manage the user experience during deferred loading.</p></br><p><code>@placeholder</code> is an optional block that declares content to show before the defer block is triggered.</p></br><p><code>@loading</code> is an optional block that allows us to declare content that will be shown during the loading of any deferred dependency.</p></br><p><code>@error</code> is an optional block. We can use this error block in case of a deferred loading failure.</p></br><pre data-language=\"plain\">\n@defer {\n  &lt;app-student&gt;&lt;/app-student&gt;\n}\n@placeholder (minimum 1000ms) {\n  &lt;p&gt;Student information table placeholder.&lt;/p&gt;\n}\n@loading (minimum 2000ms) {\n  &lt;p&gt;Loading...&lt;/p&gt;\n}\n@error {\n  &lt;p&gt;Failed to load table&lt;/p&gt;\n}\n</pre>",
                "subjectId": 2,
                "sectionId": 31,
                "subSectionId": -1,
                "contentId": 93,
                "text": "<p>Deferrable Views using <code><strong>@defer</strong></code></p>"
            },
            {
                "text": "<p>How many types we trigger<strong> Deferrable View</strong>? </p>",
                "sectionId": 31,
                "subSectionId": -1,
                "subjectId": 2,
                "contentId": 429,
                "description": "<p>There are two types of triggers that we have: <code><strong>when</strong></code> and <code><strong>on</strong></code>.</p><p><code>when</code> is a custom condition and can be defined as a Boolean expression.</p></br><pre data-language=\"plain\">\n@defer (when isLoading) {\n  &lt;app-student&gt;&lt;/app-student&gt;\n}\n@placeholder {\n  &lt;p&gt;Loading student table.&lt;/p&gt;\n}\n@loading (minimum 1000ms) {\n  &lt;p&gt;Loading...&lt;/p&gt;\n}\n</pre></br><p>There are <strong>six types of triggers</strong> that come under the <code><strong>on</strong></code> attribute: <strong>immediate, timer, idle, viewport, interaction, and hover</strong>.</p><p>The <strong>immediate</strong> trigger will render once the Angular application is rendered in the browser.</p><p>We can specify the time using the <strong>timer</strong> trigger.</p><p><strong>Idle</strong> is the default behavior. It will load the content once the browser is in an idle state.</p></br><pre data-language=\"plain\">\n@defer (on immediate) {\n  &lt;app-student&gt;&lt;/app-student&gt;\n}\n</pre></br><pre data-language=\"plain\">\n@defer (on timer(5000ms)) {\n  &lt;app-student&gt;&lt;/app-student&gt;\n}\n</pre></br><pre data-language=\"plain\">\n@defer (on idle) {\n  &lt;app-student&gt;&lt;/app-student&gt;\n}\n</pre></br><pre data-language=\"plain\">\n@defer (on viewport) {\n  &lt;app-student&gt;&lt;/app-student&gt;\n}@placeholder (minimum 5s) {\n  &lt;p&gt;Loading...&lt;/p&gt;\n}\n</pre></br><pre data-language=\"plain\">\n&lt;button #showTable&gt;Show Table Data&lt;/button&gt;\n@defer (on interaction(showTable)) {\n  &lt;app-student&gt;&lt;/app-student&gt;\n}@placeholder {\n  &lt;p&gt;Table Data&lt;/p&gt;\n}@loading (minimum 2s) {\n  &lt;p&gt;Loading Table...&lt;/p&gt;\n}\n</pre></br><pre data-language=\"plain\">\n// When I click on Table Data placeholder. Table will display.\n\n@defer(on interaction) {\n&lt;app-student&gt;&lt;/app-student&gt;\n} @placeholder {\n&lt;p&gt;Table Data&lt;/p&gt;\n} @loading(minimum 2s) {\n&lt;p&gt;Loading Table...&lt;/p&gt;\n}\n</pre></br><pre data-language=\"plain\">\n&lt;button #hoverBtn&gt;Hover Button&lt;/button&gt;\n@defer (on hover(hoverBtn)) {\n  &lt;app-student&gt;&lt;/app-student&gt;\n}@placeholder {\n  &lt;p&gt;Table Data&lt;/p&gt;\n}@loading (minimum 2s) {\n  &lt;p&gt;Loading Table...&lt;/p&gt;\n}\n</pre></br><pre data-language=\"plain\">\n// When I hover on Table Data placeholder. Table will display.\n\n@defer(on hover) {\n&lt;app-student&gt;&lt;/app-student&gt;\n} @placeholder {\n&lt;p&gt;Table Data&lt;/p&gt;\n} @loading(minimum 2s) {\n&lt;p&gt;Loading Table...&lt;/p&gt;\n}\n</pre></br><pre data-language=\"plain\">\n// We can apply OR\n@defer(on interaction; on timer(2s)) {\n&lt;app-student&gt;&lt;/app-student&gt;\n} @placeholder {\n&lt;p&gt;Table Data&lt;/p&gt;\n} @loading(minimum 2s) {\n&lt;p&gt;Loading Table...&lt;/p&gt;\n}\n</pre>"
            }
        ]
    },
    {
        "name": "<p><strong>Angular 18 Features</strong></p>",
        "subjectId": 2,
        "sectionId": 32,
        "subSectionId": -1,
        "subSections": [],
        "contents": [
            {
                "description": "<p>In <strong>Zone-based Angular</strong>, Angular uses <strong>Zone.js</strong>, and every async event triggers <strong>global change detection</strong>.</p><p>Whereas in <strong>Zoneless Angular</strong>, Angular does <strong>not</strong> use Zone.js. If needed, we can <strong>manually trigger change detection</strong>, and we can <strong>use Signals</strong> for reactive updates.</p>",
                "subjectId": 2,
                "sectionId": 32,
                "subSectionId": -1,
                "contentId": 94,
                "text": "<p>What is the difference between <strong>Zone-based</strong> and <strong>Zoneless Angular</strong>?</p>"
            }
        ]
    },
    {
        "name": "<p><strong>Angular 19 Features</strong></p>",
        "subjectId": 2,
        "sectionId": 33,
        "subSectionId": -1,
        "subSections": [],
        "contents": []
    },
    {
        "name": "<p><strong>Angular 20 Features</strong></p>",
        "subjectId": 2,
        "sectionId": 34,
        "subSectionId": -1,
        "subSections": [],
        "contents": []
    }
]